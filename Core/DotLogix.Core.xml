<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DotLogix.Core</name>
    </assembly>
    <members>
        <member name="T:DotLogix.Core.Attributes.InstantiatorAttribute">
            <summary>
            An attribute to create a new instance of <see cref="T:DotLogix.Core.Utils.Instantiator"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Attributes.InstantiatorAttribute.#ctor(DotLogix.Core.Utils.IInstantiator)">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Attributes.InstantiatorAttribute"/> using an existing <see cref="T:DotLogix.Core.Utils.IInstantiator"/>
            </summary>
            <param name="instantiator">The instance</param>
        </member>
        <member name="M:DotLogix.Core.Attributes.InstantiatorAttribute.#ctor(System.Type,System.String,System.Type)">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Attributes.InstantiatorAttribute"/> using a static property of another type
            </summary>
            <param name="singletonType">The type containing the property</param>
            <param name="propertyName">The property name</param>
            <param name="constraintType">An optional constraint type to ensure type compatibility</param>
        </member>
        <member name="M:DotLogix.Core.Attributes.InstantiatorAttribute.#ctor(System.Type,System.Type)">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Attributes.InstantiatorAttribute"/> using the default constructor of another type
            </summary>
            <param name="type">The type</param>
            <param name="constraintType">An optional constraint type to ensure type compatibility</param>
        </member>
        <member name="M:DotLogix.Core.Attributes.InstantiatorAttribute.#ctor(System.Func{System.Object})">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Attributes.InstantiatorAttribute"/> using a delegate method
            </summary>
            <param name="instantiateFunc">The factory method</param>
        </member>
        <member name="M:DotLogix.Core.Attributes.InstantiatorAttribute.GetInstance">
            <summary>
            Get or create a new instance using the configured method
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Attributes.InstantiatorAttribute.GetInstance``1">
            <summary>
            Get or create a new instance as a specific type using the configured method
            </summary>
            <typeparam name="TInstance">The target type</typeparam>
            <returns>The instance if the provided type is compatible, otherwise <value>default</value></returns>
        </member>
        <member name="T:DotLogix.Core.Attributes.ArgsInstantiatorAttribute">
            <summary>
            An attribute to create a new instance of <see cref="T:DotLogix.Core.Utils.IArgsInstantiator"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Attributes.ArgsInstantiatorAttribute.#ctor(DotLogix.Core.Utils.IArgsInstantiator)">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Attributes.ArgsInstantiatorAttribute"/> using an existing <see cref="T:DotLogix.Core.Utils.IInstantiator"/>
            </summary>
            <param name="instantiator">The instance</param>
        </member>
        <member name="M:DotLogix.Core.Attributes.ArgsInstantiatorAttribute.#ctor(System.Type,System.Type[],System.Type)">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Attributes.InstantiatorAttribute"/> using a constructor with the specified type arguments
            </summary>
            <param name="type">The type</param>
            <param name="parameterTypes">The parameter types used by the constructor</param>
            <param name="constraintType">An optional constraint type to ensure type compatibility</param>
        </member>
        <member name="M:DotLogix.Core.Attributes.ArgsInstantiatorAttribute.#ctor(System.Func{System.Object[],System.Object})">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Attributes.InstantiatorAttribute"/> using a delegate method
            </summary>
            <param name="instantiateFunc">The factory method</param>
        </member>
        <member name="M:DotLogix.Core.Attributes.ArgsInstantiatorAttribute.GetInstance(System.Object[])">
            <summary>
            Get or create a new instance using the configured method
            </summary>
            <param name="args">The arguments to create a new instance</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Attributes.ArgsInstantiatorAttribute.GetInstance``1(System.Object[])">
            <summary>
            Get or create a new instance as a specific type using the configured method
            </summary>
            <param name="args">The arguments to create a new instance</param>
            <typeparam name="TInstance">The target type</typeparam>
            <returns>The instance if the provided type is compatible, otherwise <value>default</value></returns>
        </member>
        <member name="T:DotLogix.Core.Caching.Cache`2">
            <summary>
                A concurrent version of a cache using policies to determ when values exceed
            </summary>
            <typeparam name="TKey">The type of the keys</typeparam>
            <typeparam name="TValue">The type of the values</typeparam>
        </member>
        <member name="M:DotLogix.Core.Caching.Cache`2.#ctor(System.Int32)">
            <summary>
                Creates a new instance of the cache and checks the values in the given intervall
            </summary>
        </member>
        <member name="M:DotLogix.Core.Caching.Cache`2.#ctor(System.TimeSpan)">
            <summary>
                Creates a new instance of the cache and checks the values in the given intervall
            </summary>
        </member>
        <member name="M:DotLogix.Core.Caching.Cache`2.Dispose">
            <summary>
                Disposes the cache
            </summary>
        </member>
        <member name="P:DotLogix.Core.Caching.Cache`2.CheckPolicyInterval">
            <summary>
                The timespan to check if values are no longer valid
            </summary>
        </member>
        <member name="P:DotLogix.Core.Caching.Cache`2.Count">
            <summary>
                The current amount of items
            </summary>
        </member>
        <member name="P:DotLogix.Core.Caching.Cache`2.Item(`0)">
            <summary>
                Get the value for a given key. Returns default if value can not be found
            </summary>
        </member>
        <member name="M:DotLogix.Core.Caching.Cache`2.IsAlive(`0)">
            <summary>
                Checks if a value is defined for a given key
            </summary>
        </member>
        <member name="M:DotLogix.Core.Caching.Cache`2.Store(`0,`1,DotLogix.Core.Caching.ICachePolicy)">
            <summary>
                Stores a value with the given key to the cache. Existing values will be overridden
            </summary>
            <param name="key">The key of the value</param>
            <param name="value">The vlaue</param>
            <param name="policy">
                The policy used to check if the value exceed, or null to keep the value until the cache is
                disposed
            </param>
        </member>
        <member name="M:DotLogix.Core.Caching.Cache`2.Retrieve(`0)">
            <summary>
                Retrieves a value by its key. Returns default if the key is not present
            </summary>
        </member>
        <member name="M:DotLogix.Core.Caching.Cache`2.TryRetrieve(`0,`1@)">
            <summary>
                Tries to retrieve a value by its key.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Caching.Cache`2.Pop(`0)">
            <summary>
                Gets and remove a value by its key. Returns default if the key is not present
            </summary>
        </member>
        <member name="M:DotLogix.Core.Caching.Cache`2.TryPop(`0,`1@)">
            <summary>
                Tries to get and remove a value by its key.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Caching.Cache`2.Discard(`0)">
            <summary>
                Removes a value by its key
            </summary>
        </member>
        <member name="M:DotLogix.Core.Caching.Cache`2.Cleanup">
            <summary>
                Forces a re validation of all items in the cache and removes exceeded items
            </summary>
        </member>
        <member name="M:DotLogix.Core.Caching.Cache`2.Clear">
            <summary>
                Removes all items of the cache
            </summary>
        </member>
        <member name="E:DotLogix.Core.Caching.Cache`2.ItemsDiscarded">
            <summary>
                Occures when items are discarded in the cache
            </summary>
        </member>
        <member name="M:DotLogix.Core.Caching.Cache`2.GetEnumerator">
            <summary>Returns an enumerator that iterates through the collection.</summary>
            <returns>An enumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:DotLogix.Core.Caching.Cache`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through a collection.</summary>
            <returns>An <see cref="T:System.Collections.IEnumerator"></see> object that can be used to iterate through the collection.</returns>
        </member>
        <member name="T:DotLogix.Core.Caching.CacheItem`2">
            <summary>
                An item for a cache implementation
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="P:DotLogix.Core.Caching.CacheItem`2.Key">
            <summary>
            The key
            </summary>
        </member>
        <member name="P:DotLogix.Core.Caching.CacheItem`2.Value">
            <summary>
            The value
            </summary>
        </member>
        <member name="P:DotLogix.Core.Caching.CacheItem`2.Policy">
            <summary>
            The policy to check validity
            </summary>
        </member>
        <member name="M:DotLogix.Core.Caching.CacheItem`2.#ctor(`0,`1,DotLogix.Core.Caching.ICachePolicy)">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Caching.CacheItem`2"/>
            </summary>
            <param name="key">The key</param>
            <param name="value">The value</param>
            <param name="policy">The policy to check validity</param>
        </member>
        <member name="T:DotLogix.Core.Caching.CacheItemsDiscardedEventArgs`2">
            <summary>
            An event args with the discarded items
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="P:DotLogix.Core.Caching.CacheItemsDiscardedEventArgs`2.DiscardedItems">
            <summary>
            The discarded items
            </summary>
        </member>
        <member name="M:DotLogix.Core.Caching.CacheItemsDiscardedEventArgs`2.#ctor(System.Collections.Generic.IReadOnlyList{DotLogix.Core.Caching.CacheItem{`0,`1}})">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Caching.CacheItemsDiscardedEventArgs`2"/>
            </summary>
            <param name="discardedItems"></param>
        </member>
        <member name="T:DotLogix.Core.Caching.ICache`2">
            <summary>
            An interface for cache implementations
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="P:DotLogix.Core.Caching.ICache`2.CheckPolicyInterval">
            <summary>
                The timespan to check if values are no longer valid
            </summary>
        </member>
        <member name="P:DotLogix.Core.Caching.ICache`2.Count">
            <summary>
                The current amount of items
            </summary>
        </member>
        <member name="P:DotLogix.Core.Caching.ICache`2.Item(`0)">
            <summary>
                Get the value for a given key. Returns default if value can not be found
            </summary>
        </member>
        <member name="M:DotLogix.Core.Caching.ICache`2.Dispose">
            <summary>
                Disposes the cache
            </summary>
        </member>
        <member name="M:DotLogix.Core.Caching.ICache`2.IsAlive(`0)">
            <summary>
                Checks if a value is defined for a given key
            </summary>
        </member>
        <member name="M:DotLogix.Core.Caching.ICache`2.Store(`0,`1,DotLogix.Core.Caching.ICachePolicy)">
            <summary>
                Stores a value with the given key to the cache. Existing values will be overridden
            </summary>
            <param name="key">The key of the value</param>
            <param name="value">The vlaue</param>
            <param name="policy">
                The policy used to check if the value exceed, or null to keep the value until the cache is
                disposed
            </param>
        </member>
        <member name="M:DotLogix.Core.Caching.ICache`2.Retrieve(`0)">
            <summary>
                Retrieves a value by its key. Returns default if the key is not present
            </summary>
        </member>
        <member name="M:DotLogix.Core.Caching.ICache`2.TryRetrieve(`0,`1@)">
            <summary>
                Tries to retrieve a value by its key.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Caching.ICache`2.Pop(`0)">
            <summary>
                Gets and remove a value by its key. Returns default if the key is not present
            </summary>
        </member>
        <member name="M:DotLogix.Core.Caching.ICache`2.TryPop(`0,`1@)">
            <summary>
                Tries to get and remove a value by its key.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Caching.ICache`2.Discard(`0)">
            <summary>
                Removes a value by its key
            </summary>
        </member>
        <member name="M:DotLogix.Core.Caching.ICache`2.Cleanup">
            <summary>
                Forces a re validation of all items in the cache and removes exceeded items
            </summary>
        </member>
        <member name="M:DotLogix.Core.Caching.ICache`2.Clear">
            <summary>
                Removes all items of the cache
            </summary>
        </member>
        <member name="E:DotLogix.Core.Caching.ICache`2.ItemsDiscarded">
            <summary>
                Occures when items are discarded in the cache
            </summary>
        </member>
        <member name="T:DotLogix.Core.Caching.ICachePolicy">
            <summary>
                A common interface for cache policies
            </summary>
        </member>
        <member name="M:DotLogix.Core.Caching.ICachePolicy.HasExpired(System.DateTime)">
            <summary>
            A callback method to check if an item should be dropped
            </summary>
            <param name="timeStampUtc">The timestamp when the check is happening</param>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.Caching.ValidUntilCachePolicy">
            <summary>
                A cache policy where values are valid until a given timestamp
            </summary>
        </member>
        <member name="M:DotLogix.Core.Caching.ValidUntilCachePolicy.#ctor(System.TimeSpan)">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Caching.ValidUntilCachePolicy"/>
            </summary>
            <param name="duration">The duration until the item expires</param>
        </member>
        <member name="M:DotLogix.Core.Caching.ValidUntilCachePolicy.#ctor(System.DateTime)">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Caching.ValidUntilCachePolicy"/>
            </summary>
            <param name="validUntilUtc">The time when the item has expired</param>
        </member>
        <member name="M:DotLogix.Core.Caching.ValidUntilCachePolicy.HasExpired(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Collections.Hierarchy`2">
            <summary>
            An object to describe hierarchies
            </summary>
            <typeparam name="TKey">The key type</typeparam>
            <typeparam name="TValue">The value type</typeparam>
        </member>
        <member name="P:DotLogix.Core.Collections.Hierarchy`2.Item(`0)">
            <summary>
            Get a child by its key
            </summary>
            <param name="key">The key</param>
            <returns></returns>
        </member>
        <member name="P:DotLogix.Core.Collections.Hierarchy`2.Count">
            <summary>
            The amount of children in this node
            </summary>
        </member>
        <member name="P:DotLogix.Core.Collections.Hierarchy`2.Root">
            <summary>
            The root node of the current node
            </summary>
        </member>
        <member name="P:DotLogix.Core.Collections.Hierarchy`2.IsRoot">
            <summary>
            Check if this is the root item
            </summary>
        </member>
        <member name="P:DotLogix.Core.Collections.Hierarchy`2.Ancestor">
            <summary>
            The parent node
            </summary>
        </member>
        <member name="P:DotLogix.Core.Collections.Hierarchy`2.HasAncestor">
            <summary>
            Checks if the node has an ancestor
            </summary>
        </member>
        <member name="P:DotLogix.Core.Collections.Hierarchy`2.Key">
            <summary>
            The key
            </summary>
        </member>
        <member name="P:DotLogix.Core.Collections.Hierarchy`2.Value">
            <summary>
            The value
            </summary>
        </member>
        <member name="M:DotLogix.Core.Collections.Hierarchy`2.#ctor(`0,`1,DotLogix.Core.Collections.Hierarchy{`0,`1})">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Collections.Hierarchy`2"/>
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="ancestor"></param>
        </member>
        <member name="M:DotLogix.Core.Collections.Hierarchy`2.Children">
            <summary>
            Enumerates the child nodes
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Collections.Hierarchy`2.Values">
            <summary>
            Enumerates the child values
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Collections.Hierarchy`2.Ancestors">
            <summary>
            Enumerates all ancestors
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Collections.Hierarchy`2.Descendants">
            <summary>
            Enumerates all descendants
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Collections.Hierarchy`2.Clear">
            <summary>
            Clears all children
            </summary>
        </member>
        <member name="M:DotLogix.Core.Collections.Hierarchy`2.RemoveChild(`0)">
            <summary>
            Removes a child matching the key
            </summary>
            <param name="key">The key</param>
        </member>
        <member name="M:DotLogix.Core.Collections.Hierarchy`2.GetChild(`0)">
            <summary>
            Get a child by its key
            </summary>
            <param name="key">The key</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:DotLogix.Core.Collections.Hierarchy`2.TryGetChild(`0,DotLogix.Core.Collections.Hierarchy{`0,`1}@)">
            <summary>
            Tries to get a child by its key
            </summary>
            <param name="key">The key</param>
            <param name="child">The child if present</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Collections.Hierarchy`2.GetValue(`0,`1)">
            <summary>
            Get the value of a child or a default value if child does not exist
            </summary>
            <param name="key"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Collections.Hierarchy`2.TryGetValue(`0,`1@)">
            <summary>
            Tries to get the value of a child
            </summary>
            <param name="key"></param>
            <param name="value">The value if the child exists</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Collections.Hierarchy`2.AddChild(DotLogix.Core.Collections.Hierarchy{`0,`1})">
            <summary>
            Add a child to the node
            </summary>
            <param name="child"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:DotLogix.Core.Collections.Hierarchy`2.AddChild(`0,`1)">
            <summary>
            Creates a new node with the key and value provided
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Collections.Hierarchy`2.AddChildren(System.Collections.Generic.IEnumerable{DotLogix.Core.Collections.Hierarchy{`0,`1}})">
            <summary>
            Add multiple children to the node
            </summary>
            <param name="children"></param>
        </member>
        <member name="T:DotLogix.Core.Collections.ILayeredCollection`2">
            <summary>
            A collection with multiple layers, useful for stacked collections
            </summary>
            <typeparam name="TValue"></typeparam>
            <typeparam name="TCollection"></typeparam>
        </member>
        <member name="P:DotLogix.Core.Collections.ILayeredCollection`2.Layers">
            <summary>
            The layers of collections
            </summary>
        </member>
        <member name="P:DotLogix.Core.Collections.ILayeredCollection`2.CurrentLayer">
            <summary>
            The topmost layer
            </summary>
        </member>
        <member name="M:DotLogix.Core.Collections.ILayeredCollection`2.PushLayer(`1)">
            <summary>
            Add a new layer to the collection
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:DotLogix.Core.Collections.ILayeredCollection`2.PopLayer">
            <summary>
            Removes the topmost layer from the stack
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Collections.ILayeredCollection`2.PeekLayer">
            <summary>
            Get the topmost layer but don't remove it
            </summary>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.Collections.ILayeredDictionary`3">
            <summary>
            A collection with multiple dictionary layers, useful for cascading dictionaries
            </summary>
            <typeparam name="TKey">The key type</typeparam>
            <typeparam name="TValue">The value type</typeparam>
            <typeparam name="TDictionary">The dictionary type</typeparam>
        </member>
        <member name="T:DotLogix.Core.Collections.KeyedCollection`2">
            <summary>
            A collection indexed by a unique key
            </summary>
            <typeparam name="TKey">They key</typeparam>
            <typeparam name="TValue">The value</typeparam>
        </member>
        <member name="P:DotLogix.Core.Collections.KeyedCollection`2.InnerDictionary">
            <summary>
            The internal dictionary
            </summary>
        </member>
        <member name="P:DotLogix.Core.Collections.KeyedCollection`2.KeySelector">
            <summary>
            The selector method
            </summary>
        </member>
        <member name="P:DotLogix.Core.Collections.KeyedCollection`2.Item(`0)">
            <summary>
            Get a value by its key
            </summary>
            <param name="key">The key</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Collections.KeyedCollection`2.#ctor(System.Func{`1,`0})">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Collections.KeyedCollection`2"/>
            </summary>
            <param name="keySelector">The key selector</param>
        </member>
        <member name="M:DotLogix.Core.Collections.KeyedCollection`2.#ctor(System.Func{`1,`0},System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Collections.KeyedCollection`2"/>
            </summary>
            <param name="keySelector">The key selector</param>
            <param name="values">The initial values</param>
        </member>
        <member name="M:DotLogix.Core.Collections.KeyedCollection`2.#ctor(System.Func{`1,`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Collections.KeyedCollection`2"/>
            </summary>
            <param name="keySelector">The key selector</param>
            <param name="equalityComparer">The equality comparer</param>
        </member>
        <member name="M:DotLogix.Core.Collections.KeyedCollection`2.#ctor(System.Func{`1,`0},System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Collections.KeyedCollection`2"/>
            </summary>
            <param name="keySelector">The key selector</param>
            <param name="equalityComparer">The equality comparer</param>
            <param name="values">The initial values</param>
        </member>
        <member name="M:DotLogix.Core.Collections.KeyedCollection`2.CopyTo(`1[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:DotLogix.Core.Collections.KeyedCollection`2.Count">
            <summary>
            Get the amount of items in the collection
            </summary>
        </member>
        <member name="P:DotLogix.Core.Collections.KeyedCollection`2.Keys">
            <summary>
            The keys of the collection
            </summary>
        </member>
        <member name="P:DotLogix.Core.Collections.KeyedCollection`2.Pairs">
            <summary>
            The key value paires of the collection
            </summary>
        </member>
        <member name="P:DotLogix.Core.Collections.KeyedCollection`2.System#Collections#Generic#ICollection{TValue}#IsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Collections.KeyedCollection`2.Clear">
            <summary>
            Removes all values from the collection
            </summary>
        </member>
        <member name="M:DotLogix.Core.Collections.KeyedCollection`2.Contains(`1)">
            <summary>
            Checks if the collection contains a value
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Collections.KeyedCollection`2.System#Collections#Generic#ICollection{TValue}#Add(`1)">
            <summary>
            Add an item to the collection
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:DotLogix.Core.Collections.KeyedCollection`2.System#Collections#Generic#ICollection{TValue}#Remove(`1)">
            <summary>
            Remove an item from the collection
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:DotLogix.Core.Collections.KeyedCollection`2.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Collections.KeyedCollection`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Collections.KeyedCollection`2.TryAdd(`1)">
            <summary>
            Tries to add a value to the collection
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Collections.KeyedCollection`2.GetOrAdd(`1)">
            <summary>
            Get the existing item or adds a new one matched by their keys
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Collections.KeyedCollection`2.AddOrUpdate(`1)">
            <summary>
            Add or update a value to the collection
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Collections.KeyedCollection`2.TryRemove(`1)">
            <summary>
            Tries to remove a value from the collection
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Collections.KeyedCollection`2.TryGet(`0,`1@)">
            <summary>
            Tries to get a value by key
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Collections.KeyedCollection`2.TryRemoveKey(`0)">
            <summary>
            Tries to remove the value with the matching key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Collections.KeyedCollection`2.ContainsKey(`0)">
            <summary>
            Checks if a key exists in the collection
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.Collections.LayeredCollection`2">
            <inheritdoc />
        </member>
        <member name="P:DotLogix.Core.Collections.LayeredCollection`2.LayerStack">
            <summary>
            The internal stack of collections
            </summary>
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredCollection`2.#ctor">
            <summary>Initializes a new instance of the <see cref="T:System.Object"></see> class.</summary>
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredCollection`2.#ctor(System.Collections.Generic.IEnumerable{`1})">
            <summary>Initializes a new instance of the <see cref="T:DotLogix.Core.Collections.LayeredCollection`2"></see> class.</summary>
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredCollection`2.#ctor(`1)">
            <summary>Initializes a new instance of the <see cref="T:DotLogix.Core.Collections.LayeredCollection`2"></see> class.</summary>
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredCollection`2.GetEnumerator">
            <summary>Returns an enumerator that iterates through the collection.</summary>
            <returns>An enumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredCollection`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through a collection.</summary>
            <returns>
                An <see cref="T:System.Collections.IEnumerator"></see> object that can be used to iterate through the
                collection.
            </returns>
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredCollection`2.Add(`0)">
            <summary>Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</summary>
            <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</param>
            <exception cref="T:System.NotSupportedException">
                The <see cref="T:System.Collections.Generic.ICollection`1"></see> is
                read-only.
            </exception>
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredCollection`2.Clear">
            <summary>Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</summary>
            <exception cref="T:System.NotSupportedException">
                The <see cref="T:System.Collections.Generic.ICollection`1"></see> is
                read-only.
            </exception>
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredCollection`2.Contains(`0)">
            <summary>
                Determines whether the <see cref="T:System.Collections.Generic.ICollection`1"></see> contains a specific
                value.
            </summary>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</param>
            <returns>
                true if <paramref name="item">item</paramref> is found in the
                <see cref="T:System.Collections.Generic.ICollection`1"></see>; otherwise, false.
            </returns>
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredCollection`2.CopyTo(`0[],System.Int32)">
            <summary>
                Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1"></see> to an
                <see cref="T:System.Array"></see>, starting at a particular <see cref="T:System.Array"></see> index.
            </summary>
            <param name="array">
                The one-dimensional <see cref="T:System.Array"></see> that is the destination of the elements
                copied from <see cref="T:System.Collections.Generic.ICollection`1"></see>. The <see cref="T:System.Array"></see>
                must have zero-based indexing.
            </param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array">array</paramref> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="arrayIndex">arrayIndex</paramref> is less than
                0.
            </exception>
            <exception cref="T:System.ArgumentException">
                The number of elements in the source
                <see cref="T:System.Collections.Generic.ICollection`1"></see> is greater than the available space from
                <paramref name="arrayIndex">arrayIndex</paramref> to the end of the destination
                <paramref name="array">array</paramref>.
            </exception>
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredCollection`2.Remove(`0)">
            <summary>
                Removes the first occurrence of a specific object from the
                <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </summary>
            <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</param>
            <returns>
                true if <paramref name="item">item</paramref> was successfully removed from the
                <see cref="T:System.Collections.Generic.ICollection`1"></see>; otherwise, false. This method also returns false if
                <paramref name="item">item</paramref> is not found in the original
                <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </returns>
            <exception cref="T:System.NotSupportedException">
                The <see cref="T:System.Collections.Generic.ICollection`1"></see> is
                read-only.
            </exception>
        </member>
        <member name="P:DotLogix.Core.Collections.LayeredCollection`2.Count">
            <summary>Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</summary>
            <returns>The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</returns>
        </member>
        <member name="P:DotLogix.Core.Collections.LayeredCollection`2.IsReadOnly">
            <summary>
                Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1"></see> is
                read-only.
            </summary>
            <returns>true if the <see cref="T:System.Collections.Generic.ICollection`1"></see> is read-only; otherwise, false.</returns>
        </member>
        <member name="P:DotLogix.Core.Collections.LayeredCollection`2.Layers">
            <inheritdoc />
        </member>
        <member name="P:DotLogix.Core.Collections.LayeredCollection`2.CurrentLayer">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredCollection`2.PushLayer(`1)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredCollection`2.PopLayer">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredCollection`2.PeekLayer">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Collections.LayeredDictionary`3">
            <inheritdoc />
        </member>
        <member name="P:DotLogix.Core.Collections.LayeredDictionary`3.LayerStack">
            <summary>
            The internal stack of dictionaries
            </summary>
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredDictionary`3.#ctor">
            <summary>Initializes a new instance of the <see cref="T:System.Object"></see> class.</summary>
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredDictionary`3.#ctor(System.Collections.Generic.IEnumerable{`2})">
            <summary>Initializes a new instance of the <see cref="T:System.Object"></see> class.</summary>
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredDictionary`3.#ctor(`2)">
            <summary>Initializes a new instance of the <see cref="T:System.Object"></see> class.</summary>
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredDictionary`3.GetEnumerator">
            <summary>Returns an enumerator that iterates through the collection.</summary>
            <returns>An enumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredDictionary`3.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through a collection.</summary>
            <returns>
                An <see cref="T:System.Collections.IEnumerator"></see> object that can be used to iterate through the
                collection.
            </returns>
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredDictionary`3.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</summary>
            <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</param>
            <exception cref="T:System.NotSupportedException">
                The <see cref="T:System.Collections.Generic.ICollection`1"></see> is
                read-only.
            </exception>
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredDictionary`3.Clear">
            <summary>Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</summary>
            <exception cref="T:System.NotSupportedException">
                The <see cref="T:System.Collections.Generic.ICollection`1"></see> is
                read-only.
            </exception>
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredDictionary`3.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
                Determines whether the <see cref="T:System.Collections.Generic.ICollection`1"></see> contains a specific
                value.
            </summary>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</param>
            <returns>
                true if <paramref name="item">item</paramref> is found in the
                <see cref="T:System.Collections.Generic.ICollection`1"></see>; otherwise, false.
            </returns>
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredDictionary`3.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
                Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1"></see> to an
                <see cref="T:System.Array"></see>, starting at a particular <see cref="T:System.Array"></see> index.
            </summary>
            <param name="array">
                The one-dimensional <see cref="T:System.Array"></see> that is the destination of the elements
                copied from <see cref="T:System.Collections.Generic.ICollection`1"></see>. The <see cref="T:System.Array"></see>
                must have zero-based indexing.
            </param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array">array</paramref> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="arrayIndex">arrayIndex</paramref> is less than
                0.
            </exception>
            <exception cref="T:System.ArgumentException">
                The number of elements in the source
                <see cref="T:System.Collections.Generic.ICollection`1"></see> is greater than the available space from
                <paramref name="arrayIndex">arrayIndex</paramref> to the end of the destination
                <paramref name="array">array</paramref>.
            </exception>
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredDictionary`3.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
                Removes the first occurrence of a specific object from the
                <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </summary>
            <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</param>
            <returns>
                true if <paramref name="item">item</paramref> was successfully removed from the
                <see cref="T:System.Collections.Generic.ICollection`1"></see>; otherwise, false. This method also returns false if
                <paramref name="item">item</paramref> is not found in the original
                <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </returns>
            <exception cref="T:System.NotSupportedException">
                The <see cref="T:System.Collections.Generic.ICollection`1"></see> is
                read-only.
            </exception>
        </member>
        <member name="P:DotLogix.Core.Collections.LayeredDictionary`3.Count">
            <summary>Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</summary>
            <returns>The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</returns>
        </member>
        <member name="P:DotLogix.Core.Collections.LayeredDictionary`3.IsReadOnly">
            <summary>
                Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1"></see> is
                read-only.
            </summary>
            <returns>true if the <see cref="T:System.Collections.Generic.ICollection`1"></see> is read-only; otherwise, false.</returns>
        </member>
        <member name="P:DotLogix.Core.Collections.LayeredDictionary`3.Layers">
            <inheritdoc />
        </member>
        <member name="P:DotLogix.Core.Collections.LayeredDictionary`3.CurrentLayer">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredDictionary`3.PushLayer(`2)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredDictionary`3.PopLayer">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredDictionary`3.PeekLayer">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredDictionary`3.Add(`0,`1)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredDictionary`3.ContainsKey(`0)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredDictionary`3.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredDictionary`3.TryGetValue(`0,`1@)">
            <inheritdoc />
        </member>
        <member name="P:DotLogix.Core.Collections.LayeredDictionary`3.Item(`0)">
            <inheritdoc />
        </member>
        <member name="P:DotLogix.Core.Collections.LayeredDictionary`3.Keys">
            <inheritdoc />
        </member>
        <member name="P:DotLogix.Core.Collections.LayeredDictionary`3.Values">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Collections.LayeredDictionary`3.Reduce(`2)">
            <summary>
            Merges all layers to the target dictionary
            </summary>
            <param name="targetDictionary"></param>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.Collections.LookupGrouping`2">
            <summary>
            A grouping class for lookups
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="P:DotLogix.Core.Collections.LookupGrouping`2.Key">
            <summary>Gets the key of the <see cref="T:System.Linq.IGrouping`2"></see>.</summary>
            <returns>The key of the <see cref="T:System.Linq.IGrouping`2"></see>.</returns>
        </member>
        <member name="M:DotLogix.Core.Collections.LookupGrouping`2.#ctor(`0,System.Collections.Generic.IEnumerable{`1})">
            <summary>Initializes a new instance of the <see cref="T:System.Object"></see> class.</summary>
        </member>
        <member name="M:DotLogix.Core.Collections.LookupGrouping`2.GetEnumerator">
            <summary>Returns an enumerator that iterates through the collection.</summary>
            <returns>An enumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:DotLogix.Core.Collections.LookupGrouping`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through a collection.</summary>
            <returns>
                An <see cref="T:System.Collections.IEnumerator"></see> object that can be used to iterate through the
                collection.
            </returns>
        </member>
        <member name="T:DotLogix.Core.Collections.MutableLookup`3">
            <summary>
            A mutable lookup collection
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <typeparam name="TCollection"></typeparam>
        </member>
        <member name="P:DotLogix.Core.Collections.MutableLookup`3.Keys">
            <summary>
                Gets an <see cref="T:System.Collections.Generic.ICollection`1"></see> containing the keys of the
                <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </summary>
            <returns>
                An <see cref="T:System.Collections.Generic.ICollection`1"></see> containing the keys of the object that
                implements <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </returns>
        </member>
        <member name="P:DotLogix.Core.Collections.MutableLookup`3.Values">
            <summary>
                Gets an <see cref="T:System.Collections.Generic.ICollection`1"></see> containing the values in the
                <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </summary>
            <returns>
                An <see cref="T:System.Collections.Generic.ICollection`1"></see> containing the values in the object that
                implements <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </returns>
        </member>
        <member name="P:DotLogix.Core.Collections.MutableLookup`3.Item(`0)">
            <summary>
                Gets the <see cref="T:System.Collections.Generic.IEnumerable`1"></see> sequence of values indexed by a
                specified key.
            </summary>
            <param name="key">The key of the desired sequence of values.</param>
            <returns>
                The <see cref="T:System.Collections.Generic.IEnumerable`1"></see> sequence of values indexed by the specified
                key.
            </returns>
        </member>
        <member name="M:DotLogix.Core.Collections.MutableLookup`3.#ctor(System.Int32,System.Func{`2})">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Collections.MutableLookup`3"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Collections.MutableLookup`3.#ctor(System.Func{`2})">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Collections.MutableLookup`3"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Collections.MutableLookup`3.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Func{`2})">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Collections.MutableLookup`3"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Collections.MutableLookup`3.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0},System.Func{`2})">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Collections.MutableLookup`3"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Collections.MutableLookup`3.GetEnumerator">
            <summary>Returns an enumerator that iterates through the collection.</summary>
            <returns>An enumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:DotLogix.Core.Collections.MutableLookup`3.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through a collection.</summary>
            <returns>
                An <see cref="T:System.Collections.IEnumerator"></see> object that can be used to iterate through the
                collection.
            </returns>
        </member>
        <member name="M:DotLogix.Core.Collections.MutableLookup`3.Contains(`0)">
            <summary>Determines whether a specified key exists in the <see cref="T:DotLogix.Core.Collections.MutableLookup`3"></see>.</summary>
            <param name="key">The key to search for in the <see cref="T:DotLogix.Core.Collections.MutableLookup`3"></see>.</param>
            <returns>
                true if <paramref name="key">key</paramref> is in the <see cref="T:DotLogix.Core.Collections.MutableLookup`3"></see>; otherwise,
                false.
            </returns>
        </member>
        <member name="P:DotLogix.Core.Collections.MutableLookup`3.Count">
            <summary>Gets the number of key/value collection pairs in the <see cref="T:DotLogix.Core.Collections.MutableLookup`3"></see>.</summary>
            <returns>The number of key/value collection pairs in the <see cref="T:DotLogix.Core.Collections.MutableLookup`3"></see>.</returns>
        </member>
        <member name="P:DotLogix.Core.Collections.MutableLookup`3.System#Linq#ILookup{TKey,TValue}#Item(`0)">
            <summary>
                Gets the <see cref="T:System.Collections.Generic.IEnumerable`1"></see> sequence of values indexed by a
                specified key.
            </summary>
            <param name="key">The key of the desired sequence of values.</param>
            <returns>
                The <see cref="T:System.Collections.Generic.IEnumerable`1"></see> sequence of values indexed by the specified
                key.
            </returns>
        </member>
        <member name="M:DotLogix.Core.Collections.MutableLookup`3.Clear">
            <summary>Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</summary>
            <exception cref="T:System.NotSupportedException">
                The <see cref="T:System.Collections.Generic.ICollection`1"></see> is
                read-only.
            </exception>
        </member>
        <member name="M:DotLogix.Core.Collections.MutableLookup`3.Add(`0,`1)">
            <summary>
                Adds an element with the provided key and value to the
                <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </summary>
            <param name="key">The object to use as the key of the element to add.</param>
            <param name="value">The object to use as the value of the element to add.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key">key</paramref> is null.</exception>
            <exception cref="T:System.ArgumentException">
                An element with the same key already exists in the
                <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </exception>
            <exception cref="T:System.NotSupportedException">
                The <see cref="T:System.Collections.Generic.IDictionary`2"></see> is
                read-only.
            </exception>
        </member>
        <member name="M:DotLogix.Core.Collections.MutableLookup`3.Remove(`0)">
            <summary>
                Removes the element with the specified key from the
                <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns>
                true if the element is successfully removed; otherwise, false.  This method also returns false if
                <paramref name="key">key</paramref> was not found in the original
                <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key">key</paramref> is null.</exception>
            <exception cref="T:System.NotSupportedException">
                The <see cref="T:System.Collections.Generic.IDictionary`2"></see> is
                read-only.
            </exception>
        </member>
        <member name="M:DotLogix.Core.Collections.MutableLookup`3.Remove(`0,`1)">
            <summary>
                Removes the element with the specified key from the
                <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <param name="value">The key of the element to remove.</param>
            <returns>
                true if the element is successfully removed; otherwise, false.  This method also returns false if
                <paramref name="key">key</paramref> was not found in the original
                <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key">key</paramref> is null.</exception>
            <exception cref="T:System.NotSupportedException">
                The <see cref="T:System.Collections.Generic.IDictionary`2"></see> is
                read-only.
            </exception>
        </member>
        <member name="M:DotLogix.Core.Collections.MutableLookup`3.TryGetValue(`0,`2@)">
            <summary>Gets the value associated with the specified key.</summary>
            <param name="key">The key whose value to get.</param>
            <param name="values">
                When this method returns, the value associated with the specified key, if the key is found;
                otherwise, the default value for the type of the value parameter. This parameter is passed uninitialized.
            </param>
            <returns>
                true if the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"></see> contains an
                element with the specified key; otherwise, false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key">key</paramref> is null.</exception>
        </member>
        <member name="T:DotLogix.Core.Collections.MutableLookup`2">
            <summary>
            A mutable lookup collection
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:DotLogix.Core.Collections.MutableLookup`2.#ctor">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Collections.MutableLookup`3"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Collections.MutableLookup`2.#ctor(System.Int32)">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Collections.MutableLookup`3"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Collections.MutableLookup`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Collections.MutableLookup`3"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Collections.MutableLookup`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Collections.MutableLookup`3"/>
            </summary>
        </member>
        <member name="T:DotLogix.Core.Collections.SortedCollection`1">
            <summary>
            A sorted collection, duplicates are allowed
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:DotLogix.Core.Collections.SortedCollection`1.Item(System.Int32)">
            <summary>
            Get an item by index
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:DotLogix.Core.Collections.SortedCollection`1.#ctor">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Collections.SortedCollection`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Collections.SortedCollection`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Collections.SortedCollection`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IComparer{`0})">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Collections.SortedCollection`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Collections.SortedCollection`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Collections.SortedCollection`1.Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Collections.SortedCollection`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Collections.SortedCollection`1.Contains(`0)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Collections.SortedCollection`1.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Collections.SortedCollection`1.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="P:DotLogix.Core.Collections.SortedCollection`1.Count">
            <summary>
            The element count
            </summary>
        </member>
        <member name="M:DotLogix.Core.Collections.SortedCollection`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add a range of items to the collection
            </summary>
            <param name="items"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:DotLogix.Core.Diagnostics.ConsoleLogger">
            <summary>
            A console logger implementation
            </summary>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.ConsoleLogger.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Diagnostics.ConsoleLogger"/>
            </summary>
            <param name="consoleWidth"></param>
            <param name="consoleHeight"></param>
            <param name="bufferHeight"></param>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.ConsoleLogger.Initialize">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Diagnostics.ConsoleLogger.Log(DotLogix.Core.Diagnostics.LogMessage)">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Diagnostics.ConsoleLogMessageFormatter">
            <summary>
            A console formatter
            </summary>
        </member>
        <member name="P:DotLogix.Core.Diagnostics.ConsoleLogMessageFormatter.ConsoleWidth">
            <summary>
            The target width of the console buffer
            </summary>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.ConsoleLogMessageFormatter.#ctor(System.Int32)">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Diagnostics.ConsoleLogMessageFormatter"/>
            </summary>
            <param name="consoleWidth"></param>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.ConsoleLogMessageFormatter.Format(DotLogix.Core.Diagnostics.LogMessage)">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Diagnostics.FileLogger">
            <summary>
            A file logger implementation
            </summary>
        </member>
        <member name="P:DotLogix.Core.Diagnostics.FileLogger.Directory">
            <summary>
            The log directory
            </summary>
        </member>
        <member name="P:DotLogix.Core.Diagnostics.FileLogger.LogFile">
            <summary>
            The log file name %prefix%%dd-MM-yyyy HH-mm-ss%
            </summary>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.FileLogger.#ctor(System.String,System.String)">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Diagnostics.FileLogger"/>
            </summary>
            <param name="directory"></param>
            <param name="prefix">The prefix of the date in the log message %prefix%%dd-MM-yyyy HH-mm-ss%</param>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.FileLogger.Initialize">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Diagnostics.FileLogger.Shutdown">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Diagnostics.FileLogger.Log(DotLogix.Core.Diagnostics.LogMessage)">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Diagnostics.ILogger">
            <summary>
            An interface to receive log messages
            </summary>
        </member>
        <member name="P:DotLogix.Core.Diagnostics.ILogger.Name">
            <summary>
            The name of the logger
            </summary>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.ILogger.Initialize">
            <summary>
            Initialize the logger instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.ILogger.Shutdown">
            <summary>
            Shutdown the logger instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.ILogger.Log(DotLogix.Core.Diagnostics.LogMessage)">
            <summary>
            Callback to receive messages
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.Diagnostics.ILogMessageFormatter">
            <summary>
            An interface for log message formatters
            </summary>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.ILogMessageFormatter.Format(DotLogix.Core.Diagnostics.LogMessage)">
            <summary>
            Formats a log message
            </summary>
            <param name="logMessage"></param>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.Diagnostics.Log">
            <summary>
            A static logging interface
            </summary>
        </member>
        <member name="P:DotLogix.Core.Diagnostics.Log.LogLevel">
            <summary>
            The level to log messages
            </summary>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.Log.Initialize">
            <summary>
            Initialize the log instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.Log.AttachLoggers(DotLogix.Core.Diagnostics.ILogger[])">
            <summary>
            Attach loggers to the log instance
            </summary>
            <param name="loggers"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.Log.AttachLoggers(System.Collections.Generic.IEnumerable{DotLogix.Core.Diagnostics.ILogger})">
            <summary>
            Attach loggers to the log instance
            </summary>
            <param name="loggers"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.Log.DetachLoggers(DotLogix.Core.Diagnostics.ILogger[])">
            <summary>
            Detach some loggers from the log instance
            </summary>
            <param name="loggers"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.Log.DetachLoggers(System.Collections.Generic.IEnumerable{DotLogix.Core.Diagnostics.ILogger})">
            <summary>
            Detach some loggers from the log instance
            </summary>
            <param name="loggers"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.Log.Shutdown">
            <summary>
            Shutdown the log instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.Log.Trace(System.String)">
            <summary>
            Write a trace message to the loggers
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.Log.Trace(System.Func{System.String})">
            <summary>
            Write a trace message to the loggers
            </summary>
            <param name="messageFunc"></param>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.Log.Debug(System.String)">
            <summary>
            Write a debug message to the loggers
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.Log.Debug(System.Func{System.String})">
            <summary>
            Write a debug message to the loggers
            </summary>
            <param name="messageFunc"></param>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.Log.MethodEnter">
            <summary>
            Writes a method enter message to the loggers
            </summary>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.Log.MethodExit">
            <summary>
            Writes a method exit message to the loggers
            </summary>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.Log.Info(System.String)">
            <summary>
            Writes an info message to the loggers
            </summary>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.Log.Info(System.Func{System.String})">
            <summary>
            Writes an info message to the loggers
            </summary>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.Log.Warn(System.String)">
            <summary>
            Writes a warning message to the loggers
            </summary>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.Log.Warn(System.Func{System.String})">
            <summary>
            Writes a warning message to the loggers
            </summary>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.Log.Error(System.String)">
            <summary>
            Writes a error message to the loggers
            </summary>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.Log.Error(System.Func{System.String})">
            <summary>
            Writes a error message to the loggers
            </summary>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.Log.Error(System.Exception)">
            <summary>
            Writes a error message to the loggers
            </summary>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.Log.Critical(System.Exception)">
            <summary>
            Writes a critical message to the loggers
            </summary>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.Log.Critical(System.String)">
            <summary>
            Writes a critical message to the loggers
            </summary>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.Log.Critical(System.Func{System.String})">
            <summary>
            Writes a critical message to the loggers
            </summary>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.Log.Custom(DotLogix.Core.Diagnostics.LogLevels,System.String,System.String,System.String,System.String)">
            <summary>
            Writes a custom message to the loggers
            </summary>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.Log.Custom(DotLogix.Core.Diagnostics.LogLevels,System.String,System.String,System.String,System.Func{System.String})">
            <summary>
            Writes a custom message to the loggers
            </summary>
        </member>
        <member name="T:DotLogix.Core.Diagnostics.LoggerBase">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Diagnostics.LoggerBase.#ctor(System.String)">
            <inheritdoc />
        </member>
        <member name="P:DotLogix.Core.Diagnostics.LoggerBase.Name">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Diagnostics.LoggerBase.Initialize">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Diagnostics.LoggerBase.Shutdown">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Diagnostics.LoggerBase.Log(DotLogix.Core.Diagnostics.LogMessage)">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Diagnostics.LogLevels">
            <summary>
            Log levels
            </summary>
        </member>
        <member name="F:DotLogix.Core.Diagnostics.LogLevels.Trace">
            <summary>
            Trace messages
            </summary>
        </member>
        <member name="F:DotLogix.Core.Diagnostics.LogLevels.Debug">
            <summary>
            Debug messages
            </summary>
        </member>
        <member name="F:DotLogix.Core.Diagnostics.LogLevels.Info">
            <summary>
            Info messages
            </summary>
        </member>
        <member name="F:DotLogix.Core.Diagnostics.LogLevels.Warning">
            <summary>
            Warning messages
            </summary>
        </member>
        <member name="F:DotLogix.Core.Diagnostics.LogLevels.Error">
            <summary>
            Error messages
            </summary>
        </member>
        <member name="F:DotLogix.Core.Diagnostics.LogLevels.Critical">
            <summary>
            Critical messages
            </summary>
        </member>
        <member name="F:DotLogix.Core.Diagnostics.LogLevels.Off">
            <summary>
            No logging
            </summary>
        </member>
        <member name="T:DotLogix.Core.Diagnostics.LogMessage">
            <summary>
            A log message
            </summary>
        </member>
        <member name="P:DotLogix.Core.Diagnostics.LogMessage.UtcTimeStamp">
            <summary>
            The timestamp in utc time
            </summary>
        </member>
        <member name="P:DotLogix.Core.Diagnostics.LogMessage.TimeStamp">
            <summary>
            The local timestamp
            </summary>
        </member>
        <member name="P:DotLogix.Core.Diagnostics.LogMessage.LogLevel">
            <summary>
            The log level
            </summary>
        </member>
        <member name="P:DotLogix.Core.Diagnostics.LogMessage.MethodName">
            <summary>
            The calling method
            </summary>
        </member>
        <member name="P:DotLogix.Core.Diagnostics.LogMessage.ThreadName">
            <summary>
            The thread name
            </summary>
        </member>
        <member name="P:DotLogix.Core.Diagnostics.LogMessage.ClassName">
            <summary>
            The class name
            </summary>
        </member>
        <member name="P:DotLogix.Core.Diagnostics.LogMessage.Message">
            <summary>
            The message
            </summary>
        </member>
        <member name="T:DotLogix.Core.Diagnostics.ParrallelLogger">
            <summary>
            A background-threaded hub for log messages
            </summary>
        </member>
        <member name="P:DotLogix.Core.Diagnostics.ParrallelLogger.Instance">
            <summary>
            The singleton instance
            </summary>
        </member>
        <member name="P:DotLogix.Core.Diagnostics.ParrallelLogger.SyncRoot">
            <summary>
            The sync root
            </summary>
        </member>
        <member name="P:DotLogix.Core.Diagnostics.ParrallelLogger.Initialized">
            <summary>
            A flag if the logger is initialized
            </summary>
        </member>
        <member name="P:DotLogix.Core.Diagnostics.ParrallelLogger.CurrentLogLevel">
            <summary>
            The current log level
            </summary>
        </member>
        <member name="P:DotLogix.Core.Diagnostics.ParrallelLogger.Name">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Diagnostics.ParrallelLogger.Log(DotLogix.Core.Diagnostics.LogMessage)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Diagnostics.ParrallelLogger.Initialize">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Diagnostics.ParrallelLogger.Shutdown">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Diagnostics.ParrallelLogger.AttachLogger(System.Collections.Generic.IEnumerable{DotLogix.Core.Diagnostics.ILogger})">
            <summary>
            Attach loggers to the hub
            </summary>
            <param name="loggers"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.ParrallelLogger.DetachLogger(System.Collections.Generic.IEnumerable{DotLogix.Core.Diagnostics.ILogger})">
            <summary>
            Detach loggers to the hub
            </summary>
            <param name="loggers"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.ParrallelLogger.IsLoggingEnabled(DotLogix.Core.Diagnostics.LogLevels)">
            <summary>
            Determines if a log level is high enough
            </summary>
            <param name="logLevel"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.ParrallelLogger.IsLoggingDisabled(DotLogix.Core.Diagnostics.LogLevels)">
            <summary>
            Determines if a log level is to low
            </summary>
            <param name="logLevel"></param>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.Diagnostics.TextLogMessageFormatter">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Diagnostics.TextLogMessageFormatter.Format(DotLogix.Core.Diagnostics.LogMessage)">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Diagnostics.XmlLogger">
            <summary>
            A xml logger implementation
            </summary>
        </member>
        <member name="P:DotLogix.Core.Diagnostics.XmlLogger.Directory">
            <summary>
            The log directory
            </summary>
        </member>
        <member name="P:DotLogix.Core.Diagnostics.XmlLogger.LogFile">
            <summary>
            The log file name
            </summary>
        </member>
        <member name="P:DotLogix.Core.Diagnostics.XmlLogger.SyncRoot">
            <summary>
            The sync root
            </summary>
        </member>
        <member name="M:DotLogix.Core.Diagnostics.XmlLogger.#ctor(System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Diagnostics.XmlLogger.Dispose">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Diagnostics.XmlLogger.Log(DotLogix.Core.Diagnostics.LogMessage)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Diagnostics.XmlLogger.Shutdown">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Extensions.ArrayExtensions">
            <summary>
            
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.ArrayExtensions.Split``1(``0[],``0,System.Int32,System.Int32)">
            <summary>
            Splits an array of bytes using another byte array.
            </summary>
            <param name="searchWithin">The byte array to search within</param>
            <param name="searchFor">The byte array to search</param>
            <param name="startIndex">The offset to start searching</param>
            <param name="count">The maximum amount bytes to search</param>
            <returns>The array segments</returns>
        </member>
        <member name="T:DotLogix.Core.Extensions.BinaryExtensions">
            <summary>
            A static class providing extension methods for <see cref="T:System.Byte"/> and <see cref="T:System.IO.Stream"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.BinaryExtensions.IndexOfArray(System.Byte[],System.Byte[],System.Int32,System.Int32)">
            <summary>
            Find the index of an array of bytes in another array
            </summary>
            <param name="searchWithin">The byte array to search within</param>
            <param name="serachFor">The byte array to search</param>
            <param name="startIndex">The offset to start searching</param>
            <param name="count">The maximum amount bytes to search</param>
            <returns>The index or -1 if the sequence can not be found</returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.BinaryExtensions.SplitByArray(System.Byte[],System.Byte[],System.Int32,System.Int32)">
            <summary>
            Splits an array of bytes using another byte array.
            </summary>
            <param name="searchWithin">The byte array to search within</param>
            <param name="searchFor">The byte array to search</param>
            <param name="startIndex">The offset to start searching</param>
            <param name="count">The maximum amount bytes to search</param>
            <returns>The array segments</returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.BinaryExtensions.EqualBytesLongUnrolled(System.Byte[],System.Byte[])">
            <summary>
            Checks if parts of two byte arrays are equal.<br></br>
            This method is optimized to compare long pointers instead of each byte
            </summary>
            <param name="data1">The first array</param>
            <param name="data2">The second array</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.BinaryExtensions.EqualBytesLongUnrolled(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Checks if parts of two byte arrays are equal.<br></br>
            This method is optimized to compare long pointers instead of each byte
            </summary>
            <param name="data1">The first array</param>
            <param name="data2">The second array</param>
            <param name="startIndex">The offset to start for the first array</param>
            <param name="startIndex2">The offset to start for the second array</param>
            <param name="count">The amount of bytes to compare</param>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.Extensions.CacheExtensions">
            <summary>
            A static class providing extension methods for <see cref="T:DotLogix.Core.Caching.ICache`2"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.CacheExtensions.Store``2(DotLogix.Core.Caching.ICache{``0,``1},``0,``1,System.DateTime)">
            <summary>
                Stores a value in a cache using a <see cref="T:DotLogix.Core.Caching.ValidUntilCachePolicy" /> with the given timestamp
            </summary>
            <param name="cache">The cache</param>
            <param name="key">The key of the value</param>
            <param name="value">The value</param>
            <param name="validUntilUtc">The time when the value exceed</param>
        </member>
        <member name="M:DotLogix.Core.Extensions.CacheExtensions.Store``2(DotLogix.Core.Caching.ICache{``0,``1},``0,``1,System.TimeSpan)">
            <summary>
                Stores a value in a cache using a <see cref="T:DotLogix.Core.Caching.ValidUntilCachePolicy" /> with the given duration
            </summary>
            <param name="cache">The cache</param>
            <param name="key">The key of the value</param>
            <param name="value">The value</param>
            <param name="duration">The duration until the value exceeds</param>
        </member>
        <member name="T:DotLogix.Core.Extensions.CombineMode">
            <summary>
            Combination modes of two sequences
            </summary>
        </member>
        <member name="F:DotLogix.Core.Extensions.CombineMode.Sequential">
            <summary>
            Take all of a sequence than continue to the next
            </summary>
        </member>
        <member name="F:DotLogix.Core.Extensions.CombineMode.RoundRobin">
            <summary>
            Take one of each sequence than return
            </summary>
        </member>
        <member name="F:DotLogix.Core.Extensions.CombineMode.Shuffled">
            <summary>
            Shuffle all elements in the sequence
            </summary>
        </member>
        <member name="T:DotLogix.Core.Extensions.DictionaryExtension">
            <summary>
                A static class providing extension methods for <see cref="T:System.Collections.Generic.IDictionary`2" />
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.DictionaryExtension.ReverseDictionary``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
                Reverses a dictionary so values will be the keys and the keys will be the values
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.DictionaryExtension.Reverse``2(System.Collections.Generic.KeyValuePair{``0,``1})">
            <summary>
                Reverses a key value pair so value will be the key and the key will be the value
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.DictionaryExtension.GetKey``2(System.Collections.Generic.IDictionary{``0,``1},``1)">
            <summary>
                Find the the key of an item in the dictionary
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.DictionaryExtension.TryGetKey``2(System.Collections.Generic.IDictionary{``0,``1},``1,``0@)">
            <summary>
                Tries to find the the key of an item in the dictionary
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.DictionaryExtension.Merge``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1},System.Boolean,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
                Find the the key of an item in the dictionary
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.DictionaryExtension.Merge``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.IDictionary{``0,``1}},System.Boolean,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
                Find the the key of an item in the dictionary
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.DictionaryExtension.GetValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
                Tries to get value from an <see cref="T:System.Collections.Generic.IDictionary`2" /><br></br>
                If the key is not found the method returns the default value.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.DictionaryExtension.GetValueAs``2(System.Collections.Generic.IDictionary{``0,System.Object},``0)">
            <summary>
                Tries to get value from an <see cref="T:System.Collections.Generic.IDictionary`2" /> and convert it to the target type<br></br>
                If the key is not found or the value is not convertible to the target type the method throws an exception.
            </summary>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The key does not exist</exception>
            <exception cref="T:System.InvalidCastException">The value is not convertible to the target type</exception>
        </member>
        <member name="M:DotLogix.Core.Extensions.DictionaryExtension.GetValueAs``2(System.Collections.Generic.IDictionary{``0,System.Object},``0,``1)">
            <summary>
                Tries to get value from an <see cref="T:System.Collections.Generic.IDictionary`2" /> and convert it to the target type<br></br>
                If the key is not found or the value is not convertible to the target type the method returns the default value.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.DictionaryExtension.GetValueAs``1(System.Collections.Generic.IDictionary{``0,System.Object},``0,System.Type,System.Object)">
            <summary>
                Tries to get value from an <see cref="T:System.Collections.Generic.IDictionary`2" /> and convert it to the target type<br></br>
                If the key is not found or the value is not convertible to the target type the method returns the default value.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.DictionaryExtension.TryGetValueAs``2(System.Collections.Generic.IDictionary{``0,System.Object},``0,``1@)">
            <summary>
                Tries to get value from an <see cref="T:System.Collections.Generic.IDictionary`2" /> and convert it to the target type<br></br>
                If the key is not found or the value is not convertible to the target type the method returns false.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.DictionaryExtension.TryGetValueAs``1(System.Collections.Generic.IDictionary{``0,System.Object},``0,System.Type,System.Object@)">
            <summary>
                Tries to get value from an <see cref="T:System.Collections.Generic.IDictionary`2" /> and convert it to the target type<br></br>
                If the key is not found or the value is not convertible to the target type the method returns false.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.DictionaryExtension.GetOrAdd``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
                Tries to add value to an <see cref="T:System.Collections.Generic.IDictionary`2" /><br></br>
                If the key already exist the value will be rejected and method returns the existing value.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.DictionaryExtension.GetOrAdd``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1})">
            <summary>
                Tries to add value to an <see cref="T:System.Collections.Generic.IDictionary`2" /><br></br>
                If the key does not exist the callback will be called and the value is added to the dictionary.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.DictionaryExtension.GetOrAdd``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``1})">
            <summary>
                Tries to add value to an <see cref="T:System.Collections.Generic.IDictionary`2" /><br></br>
                If the key does not exist the callback will be called and the value is added to the dictionary.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.DictionaryExtension.TryAdd``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
                Tries to add value to an <see cref="T:System.Collections.Generic.IDictionary`2" /><br></br>
                If the key already exists the value will be rejected and the method returns false.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.DictionaryExtension.PopValue``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>
                Tries to get and remove a value from an <see cref="T:System.Collections.Generic.IDictionary`2" /><br></br>
                If the key does not exist the method will throw an exception
            </summary>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The key does not exist</exception>
        </member>
        <member name="M:DotLogix.Core.Extensions.DictionaryExtension.PopValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
                Tries to get and remove a value from an <see cref="T:System.Collections.Generic.IDictionary`2" /><br></br>
                If the key does not the method returns the default value
            </summary>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The key does not exist</exception>
        </member>
        <member name="M:DotLogix.Core.Extensions.DictionaryExtension.PopValueAs``2(System.Collections.Generic.IDictionary{``0,System.Object},``0)">
            <summary>
                Tries to get and remove a value from an <see cref="T:System.Collections.Generic.IDictionary`2" /> and convert it to an other type
                <br></br>
                If the key is not found or the value is not convertible to the target type the method throws an exception.
            </summary>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The key does not exist</exception>
            <exception cref="T:System.InvalidCastException">The value is not convertible to the target type</exception>
        </member>
        <member name="M:DotLogix.Core.Extensions.DictionaryExtension.PopValueAs``2(System.Collections.Generic.IDictionary{``0,System.Object},``0,``1)">
            <summary>
                Tries to get and remove a value from an <see cref="T:System.Collections.Generic.IDictionary`2" /> and convert it to an other type
                <br></br>
                If the key is not found or the value is not convertible to the target type the method returns the default value.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.DictionaryExtension.TryPopValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1@)">
            <summary>
                Tries to get and remove a value from an <see cref="T:System.Collections.Generic.IDictionary`2" /><br></br>
                If the key is not found the method false.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.DictionaryExtension.TryPopValueAs``2(System.Collections.Generic.IDictionary{``0,System.Object},``0,``1@)">
            <summary>
                Tries to get and remove a value from an <see cref="T:System.Collections.Generic.IDictionary`2" /> and convert it to another type
                <br></br>
                If the key is not found or the value is not convertible to the target type the method returns false.
            </summary>
        </member>
        <member name="T:DotLogix.Core.Extensions.EnumerableExtensions">
            <summary>
            A static class providing extension methods for <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumerableExtensions.Enumerate``1(``0,System.Func{``0,``0},System.Func{``0,System.Boolean},System.Boolean)">
            <summary>
                Creates an enumerable of items using a selectorFunc
            </summary>
            <param name="initialValue">The initial value</param>
            <param name="selectNextFunc">A method to select the next item</param>
            <param name="hasNextFunc">A method to check if an additional value is available</param>
            <param name="yieldInitial">A flag if the initial value should be yield or skipped</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumerableExtensions.EnumerateUntil``1(``0,System.Func{``0,``0},System.Func{``0,System.Boolean},System.Boolean)">
            <summary>
                Creates an enumerable of items using a selectorFunc
            </summary>
            <param name="initialValue">The initial value</param>
            <param name="selectNextFunc">A method to select the next item</param>
            <param name="conditionFunc">A method to check if the current value should be yield</param>
            <param name="yieldInitial">A flag if the initial value should be yield or skipped</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumerableExtensions.Initialize``1(``0[],``0)">
            <summary>
                Initializes every element of the <see cref="T:System.Array"></see> with the provided value.
            </summary>
            <param name="array">The array</param>
            <param name="value">The value</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumerableExtensions.CreateArray``1(``0,System.Int32)">
            <summary>
                Creates a <see cref="T:System.Array"></see> by repeating the value n times
            </summary>
            <param name="value">The value</param>
            <param name="count">The amount of elements in the array</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumerableExtensions.CreateList``1(``0,System.Int32)">
            <summary>
                Creates a <see cref="T:System.Collections.Generic.List`1"></see> by repeating the value n times
            </summary>
            <param name="value">The value</param>
            <param name="count">The amount of elements in the list</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumerableExtensions.CreateEnumerable``1(``0,System.Int32)">
            <summary>
                Creates a <see cref="T:System.Collections.Generic.IEnumerable`1" /> by repeating the value n times
            </summary>
            <param name="value">The value</param>
            <param name="count">The amount of elements in the list</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumerableExtensions.Intercept``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0})">
            <summary>
                Intercepts an enumerable and calling a method for each of the items
            </summary>
            <param name="source">The source enumerable</param>
            <param name="interceptFunc">The interception method</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumerableExtensions.SelectWith``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``2,``1},``2)">
            <summary>
                A select, but with an additional argument
            </summary>
            <param name="source">The source enumerable</param>
            <param name="selector">The selector method</param>
            <param name="with">An additional parameter for the selector method</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumerableExtensions.Intercept``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
                Intercepts an enumerable and calling a method for each of the items
            </summary>
            <param name="source">The source enumerable</param>
            <param name="interceptAction">The interception method</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumerableExtensions.Diff``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
                Searches for differences of two enumerables using an equality comparer
            </summary>
            <param name="left">The first enumerable</param>
            <param name="right">The second enumerable</param>
            <param name="comparer">The comparer used to check equality</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumerableExtensions.Diff``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
                Searches for differences of two enumerables using a common key and a comparer
            </summary>
            <param name="left">The first enumerable</param>
            <param name="right">The second enumerable</param>
            <param name="keySelector">The method to select the key to check equality</param>
            <param name="comparer">The comparer used to check equality</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumerableExtensions.Diff``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``2},System.Collections.Generic.IEnumerable{``1},System.Func{``1,``2},System.Collections.Generic.IEqualityComparer{``2})">
            <summary>
                Searches for differences of two enumerables using a common key and a comparer
            </summary>
            <param name="left">The first enumerable</param>
            <param name="leftKeySelector">The method to select the key to check equality</param>
            <param name="right">The second enumerable</param>
            <param name="rightKeySelector">The method to select the key to check equality</param>
            <param name="comparer">The comparer used to check equality</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumerableExtensions.ToHashSet``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Converts a enumerable to a hashset
            </summary>
            <param name="enumerable">The enumerable</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumerableExtensions.ToHashSet``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
                Converts a enumerable to a hashset
            </summary>
            <param name="enumerable">The enumerable</param>
            <param name="comparer">The comparer</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumerableExtensions.AsList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Converts a enumerable to a list, but checks if it is already a list
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumerableExtensions.AsCollection``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Converts a enumerable to a collection, but checks if it is already a collection
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumerableExtensions.AsArray``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Converts a enumerable to an array, but checks if it is already an array
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumerableExtensions.TakeLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
                Takes the last n elements of a enumerable.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumerableExtensions.TakeRandom``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
                Takes the n random elements of a enumerable.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumerableExtensions.Shuffle``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Shuffles the elements in a enumerable
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumerableExtensions.Shuffle``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
                Shuffles the elements in a enumerable
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumerableExtensions.Shuffle``1(System.Collections.Generic.IEnumerable{``0},System.Random)">
            <summary>
                Shuffles the elements in a enumerable
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumerableExtensions.Balance``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
                Returns the round robin mixed combination of a list of enumerables
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumerableExtensions.Concat``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
                Returns the combination of a list of enumerables
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumerableExtensions.Shuffle``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
                Returns the shuffled combination of a list of enumerables
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumerableExtensions.Combine``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}},DotLogix.Core.Extensions.CombineMode)">
            <summary>
                Combines a list of enumerable using the given combination mode
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerables"></param>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumerableExtensions.Combine``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},DotLogix.Core.Extensions.CombineMode)">
            <summary>
                Combines a list of enumerable using the given combination mode
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="otherEnumerable"></param>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumerableExtensions.Combine``1(DotLogix.Core.Extensions.CombineMode,System.Collections.Generic.IEnumerable{``0}[])">
            <summary>
                Combines a list of enumerable using the given combination mode
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerables"></param>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumerableExtensions.Chunk``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
                Takes chunks of elements from a enumerable
            </summary>
            <param name="enumerable">The enumerable</param>
            <param name="chunkSize">The size of the chunked parts</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumerableExtensions.ToHierarchy``2(System.Collections.Generic.IEnumerable{``1},System.Func{``1,``0},System.Func{``1,``0})">
            <summary>
                Creates a hierarchy of elements using a key to determ inheritance
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="items">The items</param>
            <param name="keySelector">The method to get the key of the current element</param>
            <param name="parentKeySelector">The method to get the key of the parent element</param>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.Extensions.EnumExtensions">
            <summary>
            A static class providing extension methods for <see cref="T:System.Enum"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumExtensions.AsInt(System.Enum)">
            <summary>
                Converts a enum value to int
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.EnumExtensions.IsSingleFlag(System.Enum)">
            <summary>
                Determines if a enum value is a single flag in a flag enum (power of two)
            </summary>
        </member>
        <member name="T:DotLogix.Core.Extensions.ExpressionExtensions">
            <summary>
            A static class providing extension methods for <see cref="T:System.Linq.Expressions.Expression"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.ExpressionExtensions.GetTargetMember``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
                Gets the target member of a expression
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TTarget"></typeparam>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.ExpressionExtensions.GetTargetField``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
                Gets the target field of a expression
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TTarget"></typeparam>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.ExpressionExtensions.GetTargetProperty``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
                Gets the target property of a expression
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TTarget"></typeparam>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.Extensions.ListExtensions">
            <summary>
            A static class providing extension methods for <see cref="T:System.Collections.Generic.List`1"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.ListExtensions.TakeLast``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
                Takes the last n elements of a list
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list">The list</param>
            <param name="count">The maximum elemnts to take</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.ListExtensions.Swap``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>
                Swaps two values of a list
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list">The list</param>
            <param name="index1">The index of the first element</param>
            <param name="index2">The index of the second element</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.ListExtensions.InsertSorted``1(System.Collections.Generic.List{``0},``0)">
            <summary>
                Inserts a value in a sorted order. Only works in lists where the values are sorted already
            </summary>
            <param name="list">The list</param>
            <param name="item">The item to insert</param>
        </member>
        <member name="M:DotLogix.Core.Extensions.ListExtensions.InsertSorted``2(System.Collections.Generic.List{``0},``0,System.Func{``0,``1})">
            <summary>
                Inserts a value in a sorted order. Only works in lists where the values are sorted already
            </summary>
            <param name="list">The list</param>
            <param name="item">The item to insert</param>
            <param name="comparableSelector">The fucntion to select the key for sorting</param>
        </member>
        <member name="M:DotLogix.Core.Extensions.ListExtensions.InsertSorted``1(System.Collections.Generic.List{``0},``0,System.Collections.Generic.IComparer{``0})">
            <summary>
                Inserts a value in a sorted order. Only works in lists where the values are sorted already
            </summary>
            <param name="list">The list</param>
            <param name="item">The item to insert</param>
            <param name="comparer">The comparer used for sorting</param>
        </member>
        <member name="M:DotLogix.Core.Extensions.ListExtensions.AddRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Adds the elements of the specified collection to the end of the
                <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
            <param name="list">The list</param>
            <param name="collection">
                The collection whose elements should be added to the end of the
                <see cref="T:System.Collections.Generic.ICollection`1" />. The collection itself cannot be <see langword="null" />,
                but it can contain elements that are <see langword="null" />, if type <typeparam name="T" /> is a reference type.
            </param>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="collection" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="T:DotLogix.Core.Extensions.MathExtensions">
            <summary>
            A static class providing extension methods for numbers/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.MathExtensions.Clamp``1(``0,``0,``0)">
            <summary>
                Checks if a value is between min and max value
            </summary>
            <param name="value">The value to check</param>
            <param name="min">The min value</param>
            <param name="max">The max value</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.MathExtensions.LaysBetween``1(``0,``0,``0)">
            <summary>
                Checks if a value is between min and max value
            </summary>
            <param name="value">The value to check</param>
            <param name="min">The min value</param>
            <param name="max">The max value</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.MathExtensions.LaysBetween(System.Int32,DotLogix.Core.Utils.Patterns.Range)">
            <summary>
                Checks if a value is between min and max value
            </summary>
            <param name="value">The value to check</param>
            <param name="range">The range</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.MathExtensions.IsPowerOfTwo(System.Int32)">
            <summary>
                Checks if a value is a power of two
            </summary>
            <param name="value">The value to check</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.MathExtensions.IsPowerOfTwo(System.UInt32)">
            <summary>
                Checks if a value is a power of two
            </summary>
            <param name="value">The value to check</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.MathExtensions.IsPowerOfTwo(System.Int64)">
            <summary>
                Checks if a value is a power of two
            </summary>
            <param name="value">The value to check</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.MathExtensions.IsPowerOfTwo(System.UInt64)">
            <summary>
                Checks if a value is a power of two
            </summary>
            <param name="value">The value to check</param>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.Extensions.NullableHelper">
            <summary>
                Helper actions to unify usage of nullable structures and classes.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.NullableHelper.IsNotNull(System.Object)">
            <summary>
                Verifies nullable for null value for both reference and value types
            </summary>
            <returns> True if value is not a null </returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.NullableHelper.IsNull(System.Object)">
            <summary>
                Verifies nullable value for null for both reference and value types
            </summary>
            <returns> True if value is null </returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.NullableHelper.Cast``1(System.Object)">
            <summary>
                Casts nullable value to value and back. Both in and out types should be the same or one of them should be Nullable
                wrapper of the other one. If output type is nullable, input value can be null.
            </summary>
            <exception cref="T:System.NullReferenceException">
                Throws NullReferenceException if converting from null value to non-nullable.
                Verify with IsNull() before
            </exception>
            <exception cref="T:System.InvalidCastException">
                Throws InvalidCastException if using different types instead of nullable and
                non-nullable of the same type
            </exception>
            <returns> converted value </returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.NullableHelper.AreTypesCompatible(System.Type,System.Type)">
            <summary>
                Verifies compatibility between specified types when using this helper
            </summary>
            <remarks>
                the types are compatible if: one type is value type and another one is Nullable wrapper of the first one or both
                types are the same (for reference types)
            </remarks>
            <returns> </returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.NullableHelper.AreTypesCompatible``2">
            <summary>
                Verifies compatibility between specified types when using this helper
            </summary>
            <remarks>
                the types are compatible if: one type is value type and another one is Nullable wrapper of the first one or both
                types are the same (for reference types)
            </remarks>
            <returns> </returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.NullableHelper.IsNullable(System.Type)">
            <summary>
                Verifies is type nullable.
            </summary>
            <remarks>
                the type is nullable if it is reference type or value type wrapped with Nullable
            </remarks>
            <returns> </returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.NullableHelper.ValidateTypesCompatibility(System.Type,System.Type)">
            <summary>
                DEBUG only version of AreTypesCompatible
            </summary>
            <exception cref="T:System.InvalidCastException">throws if types are incompatible</exception>
        </member>
        <member name="M:DotLogix.Core.Extensions.NullableHelper.ValidateTypesCompatibility``2">
            <summary>
                DEBUG only version of AreTypesCompatible
            </summary>
            <exception cref="T:System.InvalidCastException">throws if types are incompatible</exception>
        </member>
        <member name="M:DotLogix.Core.Extensions.NullableHelper.ValidateNullable``1">
            <summary>
                DEBUG only version of IsNullable
            </summary>
            <exception cref="T:System.InvalidCastException">throws if type is not nullable</exception>
        </member>
        <member name="T:DotLogix.Core.Extensions.ObjectExtension">
            <summary>
            A static class providing extension methods for <see cref="T:System.Object"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.ObjectExtension.ExchangeIfDefault``1(``0,``0)">
            <summary>
            Replaces null values with the provided value
            </summary>
            <param name="source">The object</param>
            <param name="exchangeValue">The default value</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.ObjectExtension.GetDataType(System.Object)">
            <summary>
            Get the <see cref="T:DotLogix.Core.Types.DataType"/> of an object instance
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.ObjectExtension.ConvertTo(System.Object,System.Type)">
            <summary>
            Converts a value to another type using type converters
            </summary>
            <param name="value">The value</param>
            <param name="targetType">The target type</param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:DotLogix.Core.Extensions.ObjectExtension.TryConvertTo(System.Object,System.Type,System.Object@)">
            <summary>
            Tries to convert a value to another type using type converters
            </summary>
            <param name="value">The value</param>
            <param name="targetType">The target type</param>
            <param name="target">The target value</param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:DotLogix.Core.Extensions.ObjectExtension.ConvertTo``1(System.Object)">
            <summary>
            Converts a value to another type using type converters
            </summary>
            <param name="value">The value</param>
            <typeparam name="TTarget">The target type</typeparam>
            <returns></returns>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:DotLogix.Core.Extensions.ObjectExtension.TryConvertTo``1(System.Object,``0@)">
            <summary>
            Tries to convert a value to another type using type converters
            </summary>
            <param name="value">The value</param>
            <typeparam name="TTarget">The target type</typeparam>
            <param name="target">The target value</param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="T:DotLogix.Core.Extensions.ObservableCollectionExtension">
            <summary>
            A static class providing extension methods for <see cref="T:System.Collections.ObjectModel.ObservableCollection`1"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.ObservableCollectionExtension.AsReadonly``1(System.Collections.ObjectModel.ObservableCollection{``0})">
            <summary>
                Converts a observable collection to a read-only one
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.Extensions.RegexExtensions">
            <summary>
            A static class providing extension methods for <see cref="T:System.Text.RegularExpressions.Regex"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.RegexExtensions.GetValueOrDefault(System.Text.RegularExpressions.Group,System.String)">
            <summary>
            Get the value from a <see cref="T:System.Text.RegularExpressions.Group"/> or a default value if the group does not match
            </summary>
        </member>
        <member name="T:DotLogix.Core.Extensions.StreamExtensions">
            <summary>
            A static class providing extension methods for <see cref="T:System.IO.Stream"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.StreamExtensions.IndexOf(System.IO.Stream,System.Byte,System.Int64,System.Int64)">
            <summary>
            Search the first occurence of a byte in a stream
            </summary>
            <param name="searchWithin">A seekable stream</param>
            <param name="serachFor">The byte to search for</param>
            <param name="startIndex">The offset to the start of the stream or 0 to start at the current position</param>
            <param name="count">The maximum amount of bytes to search</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.StreamExtensions.IndexOfArray(System.IO.Stream,System.Byte[],System.Int64,System.Int64)">
            <summary>
            Search the first occurence of a sequence of bytes in a stream
            </summary>
            <param name="searchWithin">A seekable stream</param>
            <param name="serachFor">The sequence to search for</param>
            <param name="startIndex">The offset to the start of the stream or 0 to start at the current position</param>
            <param name="count">The maximum amount of bytes to search</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.StreamExtensions.SplitByArray(System.IO.Stream,System.Byte[],System.Int64,System.Int64)">
            <summary>
            Splits a stream into multiple sections with an array as delimiter
            </summary>
            <param name="searchWithin">A seekable stream</param>
            <param name="serachFor">The sequence to split</param>
            <param name="startIndex">The offset to the start of the stream or 0 to start at the current position</param>
            <param name="count">The maximum amount of bytes to search</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.StreamExtensions.ToByteArray(System.IO.Stream)">
            <summary>
            Reads a stream to an array of bytes
            </summary>
            <param name="stream">A readable stream</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.StreamExtensions.ToByteArrayAsync(System.IO.Stream)">
            <summary>
            Reads a stream to an array of bytes asynchronously
            </summary>
            <param name="stream">A readable stream</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.StreamExtensions.EqualBytesLongUnrolled(System.IO.Stream,System.Byte[])">
            <summary>
            Checks if a stream is equal to a sequence of bytes<br></br>
            Uses long pointer comparison instead of byte by byte
            </summary>
            <param name="data1">The stream</param>
            <param name="data2">The array</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.StreamExtensions.EqualBytesLongUnrolled(System.IO.Stream,System.Byte[],System.Int64,System.Int32,System.Int32)">
            <summary>
            Checks if a stream is equal to a sequence of bytes<br></br>
            Uses long pointer comparison instead of byte by byte
            </summary>
            <param name="data1">The seekable stream</param>
            <param name="data2">The array</param>
            <param name="startIndex">The offset to the start of the stream</param>
            <param name="startIndex2">The offset in the array</param>
            <param name="count">The count of bytes to check</param>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.Extensions.StringExtensions">
            <summary>
            A static class providing extension methods for <see cref="T:System.String"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.StringExtensions.OccurrencesOf(System.String,System.Char)">
            <summary>
                Counts the occurrences of a character in a string.
            </summary>
            <param name="str">The string</param>
            <param name="character">The character to count</param>
        </member>
        <member name="M:DotLogix.Core.Extensions.StringExtensions.OccurrencesOf(System.String,System.Char,System.Int32,System.Int32)">
            <summary>
                Counts the occurrences of a character in a string.
            </summary>
            <param name="str">The string</param>
            <param name="character">The character to count</param>
            <param name="start">The start index in the array</param>
            <param name="count">The maximum length to count</param>
        </member>
        <member name="M:DotLogix.Core.Extensions.StringExtensions.OccurrencesOf(System.Char[],System.Char)">
            <summary>
                Counts the occurrences of a character in a char array.
            </summary>
            <param name="chars">The char array</param>
            <param name="character">The character to count</param>
        </member>
        <member name="M:DotLogix.Core.Extensions.StringExtensions.OccurrencesOf(System.Char[],System.Char,System.Int32,System.Int32)">
            <summary>
                Counts the occurrences of a character in a char array.
            </summary>
            <param name="chars">The char array</param>
            <param name="character">The character to count</param>
            <param name="start">The start index in the array</param>
            <param name="count">The maximum length to count</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.StringExtensions.OccurrencesOf(System.Char[],System.Char,System.Int32,System.Int32,System.Int32@)">
            <summary>
                Counts the occurrences of a character in a char array. Also outputs the position of the last occurance of the
                character
            </summary>
            <param name="chars">The char array</param>
            <param name="character">The character to count</param>
            <param name="start">The start index in the array</param>
            <param name="count">The maximum length to count</param>
            <param name="lastOccurence">The position of the last occurance of the character</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.StringExtensions.ExchangeIfDefaultOrEmpty(System.String,System.String)">
            <summary>
                exchanges the value of source with another value if it is null, empty
            </summary>
            <param name="source">The string value</param>
            <param name="exchangeValue">The value to exchange</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.StringExtensions.ExchangeIfDefaultOrWhitespace(System.String,System.String)">
            <summary>
                exchanges the value of source with another value if it is null, empty or only contains whitespaces
            </summary>
            <param name="source">The string value</param>
            <param name="exchangeValue">The value to exchange</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.StringExtensions.SetLength(System.String,System.Char,System.Int32,System.Boolean)">
            <summary>
                Set the length of string to a specified length. If the string is longer than the string is cut in the middle, else
                it will be filled with the padding character
            </summary>
            <param name="value">The string value</param>
            <param name="padding">The padding character</param>
            <param name="length">The target length of the string</param>
            <param name="padLeft">Determines if padding should be applied left or right</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.StringExtensions.WordWrap(System.String,System.Int32)">
            <summary>
            Wraps a line of text after at a maximum amount of characters.<br></br>
            Line breaks will be inserted after the last possible word
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.StringExtensions.AppendJoin``1(System.Text.StringBuilder,System.String,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Appends some values to a <see cref="T:System.Text.StringBuilder"/> and places a separator between each item
            </summary>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:DotLogix.Core.Extensions.StringExtensions.EncodeBase64(System.String,System.Text.Encoding)">
            <summary>
                Converts a string to its base64 encoded version
            </summary>
            <param name="plain">The string to convert</param>
            <param name="encoding">The encoding used to transform the string into bytes (default is UTF8)</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.StringExtensions.EncodeBase64(System.Byte[])">
            <summary>
                Converts a byte[] to its base64 encoded version
            </summary>
            <param name="bytes">The bytes to convert</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.StringExtensions.DecodeBase64(System.String,System.Text.Encoding)">
            <summary>
                Converts a string back of its base64 encoded version
            </summary>
            <param name="base64String">The base64 encoded string</param>
            <param name="encoding">The encoding used to transform the string into bytes (default is UTF8)</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.StringExtensions.DecodeBase64ToArray(System.String)">
            <summary>
                Converts a string back of its base64 encoded version
            </summary>
            <param name="base64String">The base64 encoded string</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.StringExtensions.EncodeBase64Url(System.String,System.Text.Encoding)">
            <summary>
                Converts a string to its base64 url encoded version
            </summary>
            <param name="plain">The string to convert</param>
            <param name="encoding">The encoding used to transform the string into bytes (default is UTF8)</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.StringExtensions.EncodeBase64Url(System.Byte[])">
            <summary>
                Converts a byte[] to its base64 url encoded version
            </summary>
            <param name="bytes">The bytes to convert</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.StringExtensions.DecodeBase64Url(System.String,System.Text.Encoding)">
            <summary>
                Converts a string back of its base64 url encoded version
            </summary>
            <param name="base64String">The base64 url encoded string</param>
            <param name="encoding">The encoding used to transform the string into bytes (default is UTF8)</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.StringExtensions.DecodeBase64UrlToArray(System.String)">
            <summary>
                Converts a string back of its base64 url encoded version
            </summary>
            <param name="base64String">The base64 url encoded string</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.StringExtensions.SplitAndKeep(System.String,System.Char[])">
            <summary>
                Same as string.Split, but keeps the delimiter as an own entry in the resulting enumerable
            </summary>
            <param name="value">The string to split</param>
            <param name="delimiters">The delimiters</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.StringExtensions.SplitAndKeep(System.String,System.StringSplitOptions,System.Char[])">
            <summary>
                Same as string.Split, but keeps the delimiter as an own entry in the resulting enumerable
            </summary>
            <param name="value">The string to split</param>
            <param name="options">The options used for splitting</param>
            <param name="delimiters">The delimiters</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.StringExtensions.SplitAndKeep(System.String,System.Int32,System.Char[])">
            <summary>
                Same as string.Split, but keeps the delimiter as an own entry in the resulting enumerable
            </summary>
            <param name="value">The string to split</param>
            <param name="maxCount">The maxmimum count of splits</param>
            <param name="delimiters">The delimiters</param>
        </member>
        <member name="M:DotLogix.Core.Extensions.StringExtensions.SplitAndKeep(System.String,System.Int32,System.StringSplitOptions,System.Char[])">
            <summary>
                Same as string.Split, but keeps the delimiter as an own entry in the resulting enumerable
            </summary>
            <param name="value">The string to split</param>
            <param name="maxCount">The maxmimum count of splits</param>
            <param name="options">The options used for splitting</param>
            <param name="delimiters">The delimiters</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.StringExtensions.ParseTo(System.String,System.Type)">
            <summary>
                Convert a string to another type. Only works for the conversion of a string to primitives
            </summary>
            <param name="targetType">The target type</param>
            <param name="value">The string representation of the type</param>
            <returns>The result value if the conversion succeed</returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.StringExtensions.TryParseTo(System.String,System.Type,System.Object@)">
            <summary>
                Tries to convert a string to another type. Only works for the conversion of a string to primitives
            </summary>
            <param name="targetType">The target type</param>
            <param name="value">The string representation of the type</param>
            <param name="target">The result value if the conversion succeed</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.StringExtensions.ParseTo``1(System.String)">
            <summary>
                Convert a string to another type. Only works for the conversion of a string to primitives
            </summary>
            <typeparam name="TTarget">The target type</typeparam>
            <param name="value">The string representation of the type</param>
            <returns>The result value if the conversion succeed</returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.StringExtensions.TryParseTo``1(System.String,``0@)">
            <summary>
                Tries to convert a string to another type. Only works for the conversion of a string to primitives
            </summary>
            <typeparam name="TTarget">The target type</typeparam>
            <param name="value">The string representation of the type</param>
            <param name="target">The result value if the conversion succeed</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.StringExtensions.ConvertToEnum``1(System.String,System.Boolean)">
            <summary>
                Try to convert a string to the provided enum type
            </summary>
            <typeparam name="TEnum">The type of the enum</typeparam>
            <param name="enumValue">The string representation of a enum value</param>
            <param name="ignoreCase">Determines if the parsing should be case sensitive</param>
            <returns>The parsed enum value</returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.StringExtensions.SubstringBetween(System.String,System.String,System.String,System.Int32,System.Int32,System.StringComparison)">
            <summary>
            Get the value between two <see cref="T:System.String"/> delimiters
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.StringExtensions.SubstringUntil(System.String,System.Int32,System.Int32,System.Char[])">
            <summary>
            Get the value between before a any of the <see cref="T:System.Char"/> delimiter
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.StringExtensions.SubstringUntil(System.String,System.Char[])">
            <summary>
            Get the value between before a any of the <see cref="T:System.Char"/> delimiter
            </summary>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.Extensions.TaskExtensions">
            <summary>
            A static class providing extension methods for <see cref="T:System.Threading.Tasks.Task"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.TaskExtensions.UnpackResultAsync(System.Threading.Tasks.Task)">
            <summary>
                Takes a task and return its result as object. If the task does not have a value then null is returned
            </summary>
            <param name="task">The task</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.TaskExtensions.UnpackResult(System.Threading.Tasks.Task)">
            <summary>
                Takes a completed task and return its result as object. If the task does not have a value then null is returned.
            </summary>
            <param name="task">The task</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.TaskExtensions.ConvertResult``2(System.Threading.Tasks.Task{``1})">
            <summary>
                Converts the result of a task to a base type
            </summary>
            <typeparam name="TBase">The target type</typeparam>
            <typeparam name="TDerived">The current type</typeparam>
            <param name="task">The task</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.TaskExtensions.ConvertResult``2(System.Threading.Tasks.Task{``0},System.Func{``0,``1})">
            <summary>
                Converts the result of a task using a selector method
            </summary>
            <typeparam name="TResult">The target type</typeparam>
            <typeparam name="TSource">The current type</typeparam>
            <param name="selectorFunc">The fucntion used to convert the result</param>
            <param name="task">The task</param>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.Extensions.TextIoExtensions">
            <summary>
            A static class providing extension methods for <see cref="T:System.String"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.TextIoExtensions.AsAsyncSequence(System.IO.TextReader,System.Int32,System.Action{System.Char})">
            <summary>
            Reads the characters of a <see cref="T:System.IO.TextReader"/> async
            </summary>
            <param name="reader"></param>
            <param name="bufferSize"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.TextIoExtensions.AsSequence(System.IO.TextReader,System.Int32,System.Action{System.Char})">
            <summary>
            Reads the characters of a <see cref="T:System.IO.TextReader"/>
            </summary>
            <param name="reader"></param>
            <param name="bufferSize"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.TextIoExtensions.Write(System.IO.TextWriter,System.Char,System.Int32)">
            <summary>
            Write a char to a <see cref="T:System.IO.TextWriter"/> multiple times
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
            <param name="count"></param>
        </member>
        <member name="M:DotLogix.Core.Extensions.TextIoExtensions.WriteAsync(System.IO.TextWriter,System.Char,System.Int32)">
            <summary>
            Write a char to a <see cref="T:System.IO.TextWriter"/> multiple times async
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
            <param name="count"></param>
        </member>
        <member name="M:DotLogix.Core.Extensions.TextIoExtensions.Skip(System.IO.TextReader,System.Char[])">
            <summary>
            Skips the characters of a <see cref="T:System.IO.TextReader"/> while the character is in a blacklist
            </summary>
            <param name="reader"></param>
            <param name="chars"></param>
        </member>
        <member name="M:DotLogix.Core.Extensions.TextIoExtensions.Skip(System.IO.TextReader,System.Char)">
            <summary>
            Skips the characters of a <see cref="T:System.IO.TextReader"/> while the character equal to the one provided
            </summary>
            <param name="reader"></param>
            <param name="chr"></param>
        </member>
        <member name="M:DotLogix.Core.Extensions.TextIoExtensions.SkipWhitespace(System.IO.TextReader)">
            <summary>
            Skips whitespace characters of a <see cref="T:System.IO.TextReader"/>
            </summary>
            <param name="reader"></param>
        </member>
        <member name="M:DotLogix.Core.Extensions.TextIoExtensions.ReadUntil(System.IO.TextReader,System.Char[])">
            <summary>
            Read a string until one of the characters is hit
            </summary>
            <param name="reader"></param>
            <param name="chars"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.TextIoExtensions.ReadUntil(System.IO.TextReader,System.Char)">
            <summary>
            Read a string until the character is hit
            </summary>
            <param name="reader"></param>
            <param name="chr"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.TextIoExtensions.ReadUntilWhitespace(System.IO.TextReader)">
            <summary>
            Read a string until a whitespace character
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.Extensions.TypeExtension">
            <summary>
            A static class providing extension methods for <see cref="T:System.Type"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.TypeExtension.GetPropertiesByInheritance(System.Type)">
            <summary>
                Gets the properties of a type ordered by the inheritance level (deepest first)
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.TypeExtension.GetBaseTypes(System.Type,System.Boolean,System.Boolean)">
            <summary>
                Gets all base types of a specified type
            </summary>
            <param name="type">The type</param>
            <param name="autoOpenGenericType">get the open generic type definition of the basetypes</param>
            <param name="genericOnly">Only return generic types</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.TypeExtension.GetTypesAssignableTo(System.Type,System.Boolean,System.Boolean)">
            <summary>
                Gets all types a specified type is assignable to
            </summary>
            <param name="type">The type</param>
            <param name="autoOpenGenericType">get the open generic type definition of the basetypes</param>
            <param name="genericOnly">Only return generic types</param>
        </member>
        <member name="M:DotLogix.Core.Extensions.TypeExtension.GetInterfacesAssignableTo(System.Type,System.Boolean,System.Boolean)">
            <summary>
                Gets all interfaces a specified type is assignable to
            </summary>
            <param name="type">The type</param>
            <param name="autoOpenGenericType">get the open generic type definition of the basetypes</param>
            <param name="genericOnly">Only return generic types</param>
        </member>
        <member name="M:DotLogix.Core.Extensions.TypeExtension.OpenIfGenericType(System.Type)">
            <summary>
                Get the generic type definition of a type if it is generic
            </summary>
            <param name="type">The type</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.TypeExtension.ToDataType(System.Type)">
            <summary>
                Returns the data type of a type for more advanced informations about a type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.TypeExtension.GetDefaultValue(System.Type)">
            <summary>
                Returns the default value of a type
            </summary>
            <param name="type">The type</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.TypeExtension.IsNullableType(System.Type)">
            <summary>
                Determines if a type is a nullable type
            </summary>
            <param name="type">The type</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.TypeExtension.IsEnumerable(System.Type,System.Type@)">
            <summary>
                Determines if a type is an enumerable type, also returns the element type if possible
            </summary>
            <param name="sourceType">The type to check</param>
            <param name="elementType">The element type of the enumerable</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.TypeExtension.IsEnumerable(System.Type)">
            <summary>
                Determines if a type is an enumerable type
            </summary>
            <param name="sourceType">The type to check</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.TypeExtension.GetFriendlyName(System.Type)">
            <summary>
                Gets a more readable name for generic types or the type name if the type is not generic
            </summary>
            <param name="type">The type</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.TypeExtension.GetFriendlyGenericName(System.Type)">
            <summary>
                Gets a more readable name for generic types (including the the generic argument names) or the type name if the type
                is not generic.
            </summary>
            <param name="type">The type</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.TypeExtension.IsAssignableTo(System.Type,System.Type)">
            <summary>
                Determines if a type is assignable to another type
            </summary>
            <param name="sourceType">The type to check</param>
            <param name="targetType">The target type</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.TypeExtension.IsAssignableTo``1(System.Type)">
            <summary>
                Determines if a type is assignable to another type
            </summary>
            <param name="sourceType">The type to check</param>
            <typeparam name="TTarget">The target type</typeparam>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.TypeExtension.IsAssignableToOpenGeneric(System.Type,System.Type)">
            <summary>
                Determines if a type is assignable to an open generic type
            </summary>
            <param name="sourceType">The type to check</param>
            <param name="targetType">The open generic type</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.TypeExtension.IsAssignableToOpenGeneric(System.Type,System.Type,System.Type[]@)">
            <summary>
                Determines if a type is assignable to an open generic type, also returns the generic arguments of the constructed
                generic type
            </summary>
            <param name="sourceType">The type to check</param>
            <param name="targetType">The open generic type</param>
            <param name="genericTypeArguments">The generic arguments of the constructed generic type</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.TypeExtension.Instantiate(System.Type)">
            <summary>
                Creates a new instance of this type using the default constructor
            </summary>
            <param name="type">The type to instantiate</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.TypeExtension.Instantiate(System.Type,System.Object[])">
            <summary>
                Creates a new instance of this type using the constructor with matching parameters
            </summary>
            <param name="type">The type to instantiate</param>
            <param name="parameters">The parameters used for invoking the constructor</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.TypeExtension.Instantiate(System.Type,System.Type[])">
            <summary>
                Creates a new instance of a generic type using the provided generic arguments using the default constructor
            </summary>
            <param name="genericType">The type to instantiate</param>
            <param name="genericArguments">The generic arguments to build the type</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.TypeExtension.Instantiate(System.Type,System.Type[],System.Object[])">
            <summary>
                Creates a new instance of a generic type using the provided generic arguments using the constructor with matching
                parameters
            </summary>
            <param name="genericType">The type to instantiate</param>
            <param name="genericArguments">The generic arguments to build the type</param>
            <param name="parameters">The parameters used to invoke the constructor</param>
        </member>
        <member name="M:DotLogix.Core.Extensions.TypeExtension.Instantiate``1(System.Type)">
            <summary>
                Creates a new instance of this type using the default constructor
            </summary>
            <param name="type">The type to instantiate</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.TypeExtension.Instantiate``1(System.Type,System.Object[])">
            <summary>
                Creates a new instance of this type using the constructor with matching parameters
            </summary>
            <param name="type">The type to instantiate</param>
            <param name="parameters">The parameters used for invoking the constructor</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.TypeExtension.Instantiate``1(System.Type,System.Type[])">
            <summary>
                Creates a new instance of a generic type using the provided generic arguments using the default constructor
            </summary>
            <param name="genericType">The type to instantiate</param>
            <param name="genericArguments">The generic arguments to build the type</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.TypeExtension.Instantiate``1(System.Type,System.Type[],System.Object[])">
            <summary>
                Creates a new instance of a generic type using the provided generic arguments using the constructor with matching
                parameters
            </summary>
            <param name="genericType">The type to instantiate</param>
            <param name="genericArguments">The generic arguments to build the type</param>
            <param name="parameters">The parameters used to invoke the constructor</param>
        </member>
        <member name="M:DotLogix.Core.Extensions.TypeExtension.ToTypeArray(System.Collections.Generic.IReadOnlyList{System.Object})">
            <summary>
                Generates an array of the types of a list of objects
            </summary>
            <param name="objects">The objects</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.TypeExtension.ToTypeArray(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
                Generates an array of the types of a list of objects
            </summary>
            <param name="objects">The objects</param>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.Extensions.XmlExtension">
            <summary>
            A static class providing extension methods for <see cref="T:System.Xml.Linq.XElement"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Extensions.XmlExtension.GetElementValue(System.Xml.Linq.XElement,System.String)">
            <summary>
                Get the value of a descendent of an xml element
            </summary>
            <param name="xParent">The parent element</param>
            <param name="name">The name of the descendant</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Extensions.XmlExtension.GetAttributeValue(System.Xml.Linq.XElement,System.String)">
            <summary>
                Get the value of an attribute of an xml element
            </summary>
            <param name="xParent">The parent element</param>
            <param name="name">The name of the attribute</param>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.FunctionalDisposable">
            <summary>
            A functional class to wrap a value as a disposable to execute an action after disposal
            </summary>
        </member>
        <member name="M:DotLogix.Core.FunctionalDisposable.#ctor(System.Action)">
            <summary>Initializes a new instance of the <see cref="T:System.Object"></see> class.</summary>
        </member>
        <member name="P:DotLogix.Core.FunctionalDisposable.OnDisposeFunc">
            <summary>
            The dispose method
            </summary>
        </member>
        <member name="M:DotLogix.Core.FunctionalDisposable.Dispose">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Interfaces.ICloneable`1">
            <summary>
            A typed cloneable interface
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:DotLogix.Core.Interfaces.ICloneable`1.Clone">
            <summary>
            Clone object
            </summary>
            <returns></returns>
        </member>
        <member name="F:DotLogix.Core.Interop.Structs.FileTime.HighDateTime">
            <summary>
                Specifies the high 32 bits of the FILETIME.
            </summary>
        </member>
        <member name="F:DotLogix.Core.Interop.Structs.FileTime.LowDateTime">
            <summary>
                Specifies the low 32 bits of the FILETIME.
            </summary>
        </member>
        <member name="T:DotLogix.Core.Interop.Structs.MemoryStateEx">
            <summary>
                If your using this structure you have to set the Value of Length to 64
            </summary>
        </member>
        <member name="T:DotLogix.Core.IOptional">
            <summary>
            An interface to define optional value types
            </summary>
        </member>
        <member name="P:DotLogix.Core.IOptional.IsDefined">
            <summary>
            Checks if there is a value available
            </summary>
        </member>
        <member name="P:DotLogix.Core.IOptional.IsDefault">
            <summary>
            Checks if the value is equal to the types default value
            </summary>
        </member>
        <member name="P:DotLogix.Core.IOptional.IsUndefinedOrDefault">
            <summary>
            Checks if the value undefined or is equal to the types default value
            </summary>
        </member>
        <member name="P:DotLogix.Core.IOptional.Value">
            <summary>
            Checks if the value is equal to the types default value
            </summary>
        </member>
        <member name="M:DotLogix.Core.IOptional.GetValueOrDefault(System.Object)">
            <summary>
            Get the value or a default value if undefined
            </summary>
        </member>
        <member name="M:DotLogix.Core.IOptional.TryGetValue(System.Object@)">
            <summary>
            Tries to get the value
            </summary>
        </member>
        <member name="T:DotLogix.Core.IOptional`1">
            <inheritdoc />
        </member>
        <member name="P:DotLogix.Core.IOptional`1.Value">
            <summary>
            The value
            </summary>
        </member>
        <member name="M:DotLogix.Core.IOptional`1.GetValueOrDefault(`0)">
            <summary>
            Get the value or a default value if undefined
            </summary>
        </member>
        <member name="M:DotLogix.Core.IOptional`1.TryGetValue(`0@)">
            <summary>
            Tries to get the value
            </summary>
        </member>
        <member name="T:DotLogix.Core.Optional`1">
            <summary>
            A class to define optional value types
            </summary>
        </member>
        <member name="P:DotLogix.Core.Optional`1.Undefined">
            <summary>
            A static generic value representing the undefined state
            </summary>
        </member>
        <member name="P:DotLogix.Core.Optional`1.IsDefined">
            <inheritdoc />
        </member>
        <member name="P:DotLogix.Core.Optional`1.IsDefault">
            <inheritdoc />
        </member>
        <member name="P:DotLogix.Core.Optional`1.IsUndefinedOrDefault">
            <inheritdoc />
        </member>
        <member name="P:DotLogix.Core.Optional`1.Value">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Optional`1.#ctor(`0)">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Optional`1"/>
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:DotLogix.Core.Optional`1.GetValueOrDefault(`0)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Optional`1.TryGetValue(`0@)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Optional`1.op_Implicit(`0)~DotLogix.Core.Optional{`0}">
            <summary>
            Converts a value to a wrapped representation
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:DotLogix.Core.Optional`1.op_Explicit(DotLogix.Core.Optional{`0})~`0">
            <summary>
            Explicitly converts a wrapped representation to its inner value<br></br>
            If the value is undefined an exception is thrown
            </summary>
            <exception cref="T:System.InvalidOperationException">The value is undefined</exception>
        </member>
        <member name="M:DotLogix.Core.Optional`1.Equals(DotLogix.Core.Optional{`0})">
            <summary>
            Checks if the value is equal to another optional value
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Optional`1.Equals(`0)">
            <summary>
            Checks if the inner value is equal to another optional value
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Optional`1.Equals(System.Object)">
            <summary>Indicates whether this instance and a specified object are equal.</summary>
            <param name="obj">The object to compare with the current instance.</param>
            <returns>
                true if <paramref name="obj">obj</paramref> and this instance are the same type and represent the same value;
                otherwise, false.
            </returns>
        </member>
        <member name="M:DotLogix.Core.Optional`1.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
            <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
        </member>
        <member name="M:DotLogix.Core.Optional`1.op_Equality(DotLogix.Core.Optional{`0},DotLogix.Core.Optional{`0})">
            <summary>
                Returns a value that indicates whether the values of two <see cref="T:DotLogix.Core.Optional`1" /> objects are
                equal.
            </summary>
            <param name="left">The first value to compare.</param>
            <param name="right">The second value to compare.</param>
            <returns>
                true if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise,
                false.
            </returns>
        </member>
        <member name="M:DotLogix.Core.Optional`1.op_Inequality(DotLogix.Core.Optional{`0},DotLogix.Core.Optional{`0})">
            <summary>
                Returns a value that indicates whether two <see cref="T:DotLogix.Core.Optional`1" /> objects have different
                values.
            </summary>
            <param name="left">The first value to compare.</param>
            <param name="right">The second value to compare.</param>
            <returns>true if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, false.</returns>
        </member>
        <member name="M:DotLogix.Core.Optional`1.op_Equality(DotLogix.Core.Optional{`0},`0)">
            <summary>
                Returns a value that indicates whether the values of two <see cref="T:DotLogix.Core.Optional`1" /> objects are
                equal.
            </summary>
            <param name="left">The first value to compare.</param>
            <param name="right">The second value to compare.</param>
            <returns>
                true if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise,
                false.
            </returns>
        </member>
        <member name="M:DotLogix.Core.Optional`1.op_Inequality(DotLogix.Core.Optional{`0},`0)">
            <summary>
                Returns a value that indicates whether two <see cref="T:DotLogix.Core.Optional`1" /> objects have different
                values.
            </summary>
            <param name="left">The first value to compare.</param>
            <param name="right">The second value to compare.</param>
            <returns>true if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, false.</returns>
        </member>
        <member name="M:DotLogix.Core.Optional`1.ToString">
            <summary>Returns the fully qualified type name of this instance.</summary>
            <returns>The fully qualified type name.</returns>
        </member>
        <member name="T:DotLogix.Core.Patterns.LambdaProcessingStep`3">
            <summary>
            A pipeline step calling another method
            </summary>
            <typeparam name="TIn"></typeparam>
            <typeparam name="TResult"></typeparam>
            <typeparam name="TNext"></typeparam>
        </member>
        <member name="M:DotLogix.Core.Patterns.LambdaProcessingStep`3.#ctor(System.Func{`0,System.Func{`1,System.Threading.Tasks.Task{`2}},System.Threading.Tasks.Task{`2}})">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Patterns.LambdaProcessingStep`3"/>
            </summary>
            <param name="callback"></param>
        </member>
        <member name="M:DotLogix.Core.Patterns.LambdaProcessingStep`3.InvokeAsync(`0)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Patterns.LambdaProcessingStep`3.op_Implicit(System.Func{`0,System.Func{`1,System.Threading.Tasks.Task{`2}},System.Threading.Tasks.Task{`2}})~DotLogix.Core.Patterns.LambdaProcessingStep{`0,`1,`2}">
            <summary>
            Implicitly converts a method to a processing step
            </summary>
            <param name="next"></param>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.Patterns.LambdaProcessingStep`2">
            <summary>
            A pipeline step calling another method
            </summary>
            <typeparam name="TIn"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="M:DotLogix.Core.Patterns.LambdaProcessingStep`2.#ctor(System.Func{`0,System.Threading.Tasks.Task{`1}})">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Patterns.LambdaProcessingStep`2"/>
            </summary>
            <param name="callback"></param>
        </member>
        <member name="M:DotLogix.Core.Patterns.LambdaProcessingStep`2.InvokeAsync(`0)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Patterns.LambdaProcessingStep`2.op_Implicit(System.Func{`0,System.Threading.Tasks.Task{`1}})~DotLogix.Core.Patterns.LambdaProcessingStep{`0,`1}">
            <summary>
            Converts a method to a <see cref="T:DotLogix.Core.Patterns.LambdaProcessingStep`2"/>
            </summary>
            <param name="next"></param>
        </member>
        <member name="T:DotLogix.Core.Patterns.Pipeline`2">
            <summary>
            A pipeline implementation
            </summary>
            <typeparam name="TIn"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="P:DotLogix.Core.Patterns.Pipeline`2.Steps">
            <summary>
            The inner steps of the pipeline
            </summary>
        </member>
        <member name="M:DotLogix.Core.Patterns.Pipeline`2.InvokeAsync(`0)">
            <summary>
            Invoke the pipeline
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Patterns.Pipeline`2.GetEnumerator">
            <summary>Returns an enumerator that iterates through the collection.</summary>
            <returns>An enumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:DotLogix.Core.Patterns.Pipeline`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through a collection.</summary>
            <returns>An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:DotLogix.Core.Patterns.Pipeline`2.Add(DotLogix.Core.Patterns.ProcessingStep{`0,`0,`1})">
            <summary>Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
            <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</exception>
        </member>
        <member name="M:DotLogix.Core.Patterns.Pipeline`2.Add(System.Func{`0,System.Func{`0,System.Threading.Tasks.Task{`1}},System.Threading.Tasks.Task{`1}})">
            <summary>Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
            <param name="next">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</exception>
        </member>
        <member name="M:DotLogix.Core.Patterns.Pipeline`2.Clear">
            <summary>Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only. </exception>
        </member>
        <member name="M:DotLogix.Core.Patterns.Pipeline`2.Contains(DotLogix.Core.Patterns.ProcessingStep{`0,`0,`1})">
            <summary>Determines whether the <see cref="T:System.Collections.Generic.ICollection`1" /> contains a specific value.</summary>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
            <returns>
            <see langword="true" /> if <paramref name="item" /> is found in the <see cref="T:System.Collections.Generic.ICollection`1" />; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:DotLogix.Core.Patterns.Pipeline`2.CopyTo(DotLogix.Core.Patterns.ProcessingStep{`0,`0,`1}[],System.Int32)">
            <summary>Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.</summary>
            <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in <paramref name="array" /> at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="array" /> is <see langword="null" />.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="arrayIndex" /> is less than 0.</exception>
            <exception cref="T:System.ArgumentException">The number of elements in the source <see cref="T:System.Collections.Generic.ICollection`1" /> is greater than the available space from <paramref name="arrayIndex" /> to the end of the destination <paramref name="array" />.</exception>
        </member>
        <member name="M:DotLogix.Core.Patterns.Pipeline`2.Remove(DotLogix.Core.Patterns.ProcessingStep{`0,`0,`1})">
            <summary>Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
            <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
            <returns>
            <see langword="true" /> if <paramref name="item" /> was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1" />; otherwise, <see langword="false" />. This method also returns <see langword="false" /> if <paramref name="item" /> is not found in the original <see cref="T:System.Collections.Generic.ICollection`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</exception>
        </member>
        <member name="P:DotLogix.Core.Patterns.Pipeline`2.Count">
            <summary>Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
            <returns>The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1" />.</returns>
        </member>
        <member name="P:DotLogix.Core.Patterns.Pipeline`2.IsReadOnly">
            <summary>Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</summary>
            <returns>
            <see langword="true" /> if the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:DotLogix.Core.Patterns.Pipeline`2.IndexOf(DotLogix.Core.Patterns.ProcessingStep{`0,`0,`1})">
            <summary>Determines the index of a specific item in the <see cref="T:System.Collections.Generic.IList`1" />.</summary>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.IList`1" />.</param>
            <returns>The index of <paramref name="item" /> if found in the list; otherwise, -1.</returns>
        </member>
        <member name="M:DotLogix.Core.Patterns.Pipeline`2.Insert(System.Int32,DotLogix.Core.Patterns.ProcessingStep{`0,`0,`1})">
            <summary>Inserts an item to the <see cref="T:System.Collections.Generic.IList`1" /> at the specified index.</summary>
            <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
            <param name="item">The object to insert into the <see cref="T:System.Collections.Generic.IList`1" />.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1" />.</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1" /> is read-only.</exception>
        </member>
        <member name="M:DotLogix.Core.Patterns.Pipeline`2.RemoveAt(System.Int32)">
            <summary>Removes the <see cref="T:System.Collections.Generic.IList`1" /> item at the specified index.</summary>
            <param name="index">The zero-based index of the item to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1" />.</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1" /> is read-only.</exception>
        </member>
        <member name="P:DotLogix.Core.Patterns.Pipeline`2.Item(System.Int32)">
            <summary>Gets or sets the element at the specified index.</summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1" />.</exception>
            <exception cref="T:System.NotSupportedException">The property is set and the <see cref="T:System.Collections.Generic.IList`1" /> is read-only.</exception>
        </member>
        <member name="T:DotLogix.Core.Patterns.ProcessingStep`2">
            <summary>
            A base class for pipeline processing steps
            </summary>
            <typeparam name="TIn"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="M:DotLogix.Core.Patterns.ProcessingStep`2.InvokeAsync(`0)">
            <summary>
            Invoke the step action
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.Patterns.ProcessingStep`3">
            <summary>
            A base class for pipeline processing steps
            </summary>
            <typeparam name="TIn">The step input</typeparam>
            <typeparam name="TResult">The pipeline result</typeparam>
            <typeparam name="TNext">The input value of the next step</typeparam>
        </member>
        <member name="M:DotLogix.Core.Patterns.ProcessingStep`3.NextAsync(`1)">
            <summary>
            Calls the next pipeline step if existing
            </summary>
            <param name="value"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException">If no following step is available it is required to return a value</exception>
        </member>
        <member name="M:DotLogix.Core.Patterns.ProcessingStep`3.EndWith(DotLogix.Core.Patterns.ProcessingStep{`1,`2})">
            <summary>
            End a multi operational pipeline step
            </summary>
            <param name="next"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:DotLogix.Core.Patterns.ProcessingStep`3.ContinueWith``1(DotLogix.Core.Patterns.ProcessingStep{`1,``0,`2})">
            <summary>
            Add a pipeline step after the current
            </summary>
            <param name="next"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Patterns.ProcessingStep`3.EndWith(System.Func{`1,System.Threading.Tasks.Task{`2}})">
            <summary>
            End a multi operational pipeline step
            </summary>
            <param name="next"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:DotLogix.Core.Patterns.ProcessingStep`3.ContinueWith(System.Func{`1,System.Func{`1,System.Threading.Tasks.Task{`2}},System.Threading.Tasks.Task{`2}})">
            <summary>
            Add a pipeline step after the current
            </summary>
            <param name="next"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Patterns.ProcessingStep`3.ContinueWith``1(System.Func{`1,System.Func{``0,System.Threading.Tasks.Task{`2}},System.Threading.Tasks.Task{`2}})">
            <summary>
            Add a pipeline step after the current
            </summary>
            <param name="next"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.Patterns.Singleton`1">
            <summary>
            A generic trick to create typed singletons
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:DotLogix.Core.Patterns.Singleton`1.Instance">
            <summary>
            The instance
            </summary>
        </member>
        <member name="T:DotLogix.Core.Patterns.WrappedProcessingStep`4">
            <summary>
            A processing step executing a row of steps
            </summary>
            <typeparam name="TIn"></typeparam>
            <typeparam name="TInTail"></typeparam>
            <typeparam name="TNext"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="M:DotLogix.Core.Patterns.WrappedProcessingStep`4.#ctor(DotLogix.Core.Patterns.ProcessingStep{`0,`3},DotLogix.Core.Patterns.ProcessingStep{`1,`2,`3})">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Patterns.WrappedProcessingStep`4"/>
            </summary>
            <param name="head"></param>
            <param name="tail"></param>
        </member>
        <member name="M:DotLogix.Core.Patterns.WrappedProcessingStep`4.InvokeAsync(`0)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Patterns.WrappedProcessingStep`4.EndWith(DotLogix.Core.Patterns.ProcessingStep{`2,`3})">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Patterns.WrappedProcessingStep`4.ContinueWith``1(DotLogix.Core.Patterns.ProcessingStep{`2,``0,`3})">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Plugins.IPluginDefinition">
            <summary>
            A generic definition for plugins
            </summary>
        </member>
        <member name="P:DotLogix.Core.Plugins.IPluginDefinition.Guid">
            <summary>
            The unique id of the plugin
            </summary>
        </member>
        <member name="P:DotLogix.Core.Plugins.IPluginDefinition.Name">
            <summary>
            The name of the plugin
            </summary>
        </member>
        <member name="T:DotLogix.Core.Plugins.PluginAssembly`1">
            <summary>
            An assembly containing some instances of a plugin
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:DotLogix.Core.Plugins.PluginAssembly`1.PluginState">
            <summary>
            The loading state of the assembly
            </summary>
        </member>
        <member name="P:DotLogix.Core.Plugins.PluginAssembly`1.File">
            <summary>
            The assembly file
            </summary>
        </member>
        <member name="P:DotLogix.Core.Plugins.PluginAssembly`1.Directory">
            <summary>
            The parent directory of the assembly file
            </summary>
        </member>
        <member name="P:DotLogix.Core.Plugins.PluginAssembly`1.Assembly">
            <summary>
            The assembly
            </summary>
        </member>
        <member name="P:DotLogix.Core.Plugins.PluginAssembly`1.Instances">
            <summary>
            The containing instances of the plugin type
            </summary>
        </member>
        <member name="P:DotLogix.Core.Plugins.PluginAssembly`1.LastError">
            <summary>
            The aggregated error occurred while loading the assembly
            </summary>
        </member>
        <member name="M:DotLogix.Core.Plugins.PluginAssembly`1.#ctor(System.String)">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Plugins.PluginAssembly`1"/>
            </summary>
            <param name="file"></param>
        </member>
        <member name="M:DotLogix.Core.Plugins.PluginAssembly`1.Load(System.Object[])">
            <summary>
            Load the assembly and instantiate the matching types
            </summary>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.Plugins.PluginFactory">
            <summary>
            A factory implementation to load plugins
            </summary>
        </member>
        <member name="M:DotLogix.Core.Plugins.PluginFactory.LoadPlugins``1(System.String,System.String,System.IO.SearchOption)">
            <summary>
            Load all matching plugin types and create a new instance of the matching types
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Plugins.PluginFactory.LoadPlugins``1(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Load all matching plugin types and create a new instance of the matching types
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Plugins.PluginFactory.LoadPluginAssemblies``1(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            Load all matching files as plugin assemblies
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.Plugins.PluginState">
            <summary>
            The loading state of a plugin assembly
            </summary>
        </member>
        <member name="F:DotLogix.Core.Plugins.PluginState.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:DotLogix.Core.Plugins.PluginState.Loaded">
            <summary>
            Loaded
            </summary>
        </member>
        <member name="F:DotLogix.Core.Plugins.PluginState.Failed">
            <summary>
            Failed
            </summary>
        </member>
        <member name="T:DotLogix.Core.Reflection.Delegates.CtorDelegate">
            <summary>
            A delegate to represent constructors
            </summary>
            <param name="parameters"></param>
        </member>
        <member name="T:DotLogix.Core.Reflection.Delegates.GetterDelegate">
            <summary>
            A delegate to represent getters
            </summary>
        </member>
        <member name="T:DotLogix.Core.Reflection.Delegates.GetterDelegate`2">
            <summary>
            A delegate to represent getters
            </summary>
        </member>
        <member name="T:DotLogix.Core.Reflection.Delegates.InvokeDelegate">
            <summary>
            A delegate to represent method calls
            </summary>
        </member>
        <member name="T:DotLogix.Core.Reflection.Delegates.SetterDelegate">
            <summary>
            A delegate to represent setters
            </summary>
        </member>
        <member name="T:DotLogix.Core.Reflection.Delegates.SetterDelegate`2">
            <summary>
            A delegate to represent setters
            </summary>
        </member>
        <member name="T:DotLogix.Core.Reflection.Dynamics.AccessModifiers">
            <summary>
            Modifiers for type members
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.AccessModifiers.None">
            <summary>
            No modifier
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.AccessModifiers.Static">
            <summary>
            Static
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.AccessModifiers.Const">
            <summary>
            Const
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.AccessModifiers.Nested">
            <summary>
            Nested
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.AccessModifiers.Abstract">
            <summary>
            Abstract
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.AccessModifiers.Virtual">
            <summary>
            Virtual
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.AccessModifiers.Sealed">
            <summary>
            Sealed
            </summary>
        </member>
        <member name="T:DotLogix.Core.Reflection.Dynamics.AccessorTypes">
            <summary>
            Types of value accessors
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.AccessorTypes.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.AccessorTypes.Property">
            <summary>
            Property
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.AccessorTypes.Field">
            <summary>
            Field
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.AccessorTypes.Any">
            <summary>
            Any
            </summary>
        </member>
        <member name="T:DotLogix.Core.Reflection.Dynamics.AccessorTypesExtension">
            <summary>
            A static class providing extension methods for <see cref="T:DotLogix.Core.Reflection.Dynamics.AccessorTypes"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.AccessorTypesExtension.GetMemberTypes(DotLogix.Core.Reflection.Dynamics.AccessorTypes)">
            <summary>
            Get the internal representation of member types
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="T:DotLogix.Core.Reflection.Dynamics.DynamicAccessor">
            <summary>
            A representation of a value accessor
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicAccessor.Name">
            <summary>
            The name
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicAccessor.DeclaringType">
            <summary>
            The declaring type
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicAccessor.ReflectedType">
            <summary>
            The reflected type
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicAccessor.ValueType">
            <summary>
            The value type
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicAccessor.MemberInfo">
            <summary>
            The original member info
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicAccessor.AccessorType">
            <summary>
            The accessor type
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicAccessor.ValueAccessMode">
            <summary>
            The access modes
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicAccessor.Setter">
            <summary>
            The setter delegate
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicAccessor.Getter">
            <summary>
            The getter delegate
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicAccessor.CanRead">
            <summary>
            Check if the accessor is readable
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicAccessor.CanWrite">
            <summary>
            Check if the accessor is writable
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.DynamicAccessor.#ctor(System.Reflection.MemberInfo,DotLogix.Core.Reflection.Dynamics.DynamicSetter,DotLogix.Core.Reflection.Dynamics.DynamicGetter,System.Type,DotLogix.Core.Reflection.Dynamics.AccessorTypes)">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Reflection.Dynamics.DynamicAccessor"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.DynamicAccessor.SetValue(System.Object)">
            <summary>
            Set the value of the accessor<br></br>
            The accessor must be static
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.DynamicAccessor.SetValue(System.Object,System.Object)">
            <summary>
            Set the value of the accessor
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.DynamicAccessor.GetValue">
            <summary>
            Get the value of the accessor<br></br>
            The accessor must be static
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.DynamicAccessor.GetValue(System.Object)">
            <summary>
            Get the value of the accessor<br></br>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.DynamicAccessor.ToString">
            <summary>
            Returns a representation of the accessor including access modes
            </summary>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="T:DotLogix.Core.Reflection.Dynamics.DynamicCtor">
            <summary>
            A representation of a constructor
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicCtor.ConstructorInfo">
            <summary>
            The original constructor info
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicCtor.Access">
            <summary>
            The access modifiers
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicCtor.Visibility">
            <summary>
            The visibility modifiers
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicCtor.CtorDelegate">
            <summary>
            The constructor delegate
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicCtor.DeclaringType">
            <summary>
            The declaring type
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicCtor.Parameters">
            <summary>
            The parameters
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicCtor.ParameterTypes">
            <summary>
            The parameter types
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicCtor.ParameterCount">
            <summary>
            The parameter count
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicCtor.IsDefault">
            <summary>
            The constructor does not require arguments
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.DynamicCtor.Invoke(System.Object[])">
            <summary>
            Invoke the constructor and create a new instance
            </summary>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.DynamicCtor.ToString">
            <summary>
            Returns a representation of the constructor with its parameter type names
            </summary>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.Reflection.Dynamics.DynamicField">
            <summary>
            A representation of a field
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicField.FieldInfo">
            <summary>
            The original field info
            </summary>
        </member>
        <member name="T:DotLogix.Core.Reflection.Dynamics.DynamicGetter">
            <summary>
            A representation of a getter
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicGetter.Access">
            <summary>
            The access modifiers
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicGetter.Visibility">
            <summary>
            The visibility modifiers
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicGetter.GetterDelegate">
            <summary>
            The getter delegate
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.DynamicGetter.GetValue">
            <summary>
            Get the value<br></br>
            The field must be static
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.DynamicGetter.GetValue(System.Object)">
            <summary>
            Get the value
            </summary>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.Reflection.Dynamics.DynamicInvoke">
            <summary>
            A representation of a method
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicInvoke.MethodInfo">
            <summary>
            The original method info
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicInvoke.Access">
            <summary>
            The access modifiers
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicInvoke.Visibility">
            <summary>
            The visibility modifiers
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicInvoke.InvokeDelegate">
            <summary>
            The invocation delegate
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicInvoke.DeclaringType">
            <summary>
            The declaring type
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicInvoke.ReturnType">
            <summary>
            The return type
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicInvoke.Parameters">
            <summary>
            The parameter infos
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicInvoke.ParameterTypes">
            <summary>
            The parameter types
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicInvoke.ParameterCount">
            <summary>
            The parameter count
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicInvoke.Name">
            <summary>
            The name
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.DynamicInvoke.StaticInvoke(System.Object[])">
            <summary>
            Invoke the delegate with the provided parameters.<br></br>
            The method must be static
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.DynamicInvoke.Invoke(System.Object,System.Object[])">
            <summary>
            Invoke the delegate with the provided parameters.<br></br>
            The method must be static
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.DynamicInvoke.ToString">
            <summary>
            Returns a string representation of the method with its parameters
            </summary>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.Reflection.Dynamics.DynamicMemberTypes">
            <summary>
            Types of members
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.DynamicMemberTypes.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.DynamicMemberTypes.Constructor">
            <summary>
            Constructors
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.DynamicMemberTypes.Event">
            <summary>
            Events
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.DynamicMemberTypes.Field">
            <summary>
            Fields
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.DynamicMemberTypes.Method">
            <summary>
            Methods
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.DynamicMemberTypes.Property">
            <summary>
            Properties
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.DynamicMemberTypes.Type">
            <summary>
            Types
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.DynamicMemberTypes.NestedType">
            <summary>
            Nested types
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.DynamicMemberTypes.Accessor">
            <summary>
            Accessors
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.DynamicMemberTypes.Any">
            <summary>
            Any
            </summary>
        </member>
        <member name="T:DotLogix.Core.Reflection.Dynamics.DynamicProperty">
            <summary>
            A representation of a property
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicProperty.PropertyInfo">
            <summary>
            The original property info
            </summary>
        </member>
        <member name="T:DotLogix.Core.Reflection.Dynamics.DynamicSetter">
            <summary>
            A representation of a setter
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicSetter.Access">
            <summary>
            The access modifiers
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicSetter.Visibility">
            <summary>
            The visibility modifiers
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicSetter.SetterDelegate">
            <summary>
            The setter delegate
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.DynamicSetter.SetValue(System.Object)">
            <summary>
            Set the value<br></br>
            The field must be static
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.DynamicSetter.SetValue(System.Object,System.Object)">
            <summary>
            Set the value
            </summary>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.Reflection.Dynamics.DynamicType">
            <summary>
            A representation of a type
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicType.Type">
            <summary>
            The original type
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicType.Name">
            <summary>
            The name
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicType.Constructors">
            <summary>
            The constructors
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicType.Methods">
            <summary>
            The methods
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicType.Accessors">
            <summary>
            The accessors
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicType.Properties">
            <summary>
            The properties
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicType.Fields">
            <summary>
            The fields
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Dynamics.DynamicType.HasDefaultConstructor">
            <summary>
            Checks if there is a default constructor
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.DynamicType.#ctor(System.Type,System.Reflection.MemberTypes)">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Reflection.Dynamics.DynamicType"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.DynamicType.ToString">
            <summary>
            Returns the name of the type
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.DynamicType.GetProperty(System.String)">
            <summary>
            Tries to get a property.<br></br>
            If the property can not be found the method returns null
            </summary>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.DynamicType.GetField(System.String)">
            <summary>
            Tries to get a field.<br></br>
            If the field can not be found the method returns null
            </summary>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.DynamicType.GetAccessor(System.String)">
            <summary>
            Tries to get a accessor.<br></br>
            If the accessor can not be found the method returns null
            </summary>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.DynamicType.GetAccessors(DotLogix.Core.Reflection.Dynamics.AccessorTypes,DotLogix.Core.Reflection.Dynamics.ValueAccessModes)">
            <summary>
            Enumerate all accessors of the type
            </summary>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.DynamicType.GetMethod(System.String)">
            <summary>
            Tries to get a method.<br></br>
            If the method can not be found the method returns null
            </summary>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.DynamicType.GetMethod(System.String,System.Type[])">
            <summary>
            Tries to get a method.<br></br>
            If the method can not be found the method returns null
            </summary>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.DynamicType.GetMethods(System.String)">
            <summary>
            Enumerate all methods
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.DynamicType.GetConstructor(System.Type[])">
            <summary>
            Tries to get a constructor.<br></br>
            If the constructor can not be found the method returns null
            </summary>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.DynamicType.GetDefaultConstructor">
            <summary>
            Tries to get a constructor.<br></br>
            If the constructor can not be found the method returns null
            </summary>
        </member>
        <member name="T:DotLogix.Core.Reflection.Dynamics.FluentDynamics">
            <summary>
            A static class providing extension methods for <see cref="T:DotLogix.Core.Reflection.Dynamics.DynamicType"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.FluentDynamics.CreateDynamicType(System.Type,System.Reflection.MemberTypes)">
            <summary>
            Create a dynamic type representation of a system type
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.FluentDynamics.CreateDynamicInvoke(System.Reflection.MethodInfo)">
            <summary>
            Create a dynamic type representation of a method
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.FluentDynamics.CreateDynamicCtor(System.Reflection.ConstructorInfo,System.Boolean)">
            <summary>
            Create a dynamic type representation of a constructor
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.FluentDynamics.CreateDynamicCtor(System.Type,System.Type[],System.Boolean)">
            <summary>
            Create a dynamic type representation of a constructor
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.FluentDynamics.CreateDefaultCtor(System.Type,System.Boolean)">
            <summary>
            Create a dynamic type representation of a default constructor
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.FluentDynamics.CreateDynamicGetter(System.Reflection.PropertyInfo)">
            <summary>
            Create a dynamic type representation of a getter
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.FluentDynamics.CreateDynamicGetter(System.Reflection.FieldInfo)">
            <summary>
            Create a dynamic type representation of a getter
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.FluentDynamics.CreateDynamicSetter(System.Reflection.PropertyInfo)">
            <summary>
            Create a dynamic type representation of a setter
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.FluentDynamics.CreateDynamicSetter(System.Reflection.FieldInfo)">
            <summary>
            Create a dynamic type representation of a setter
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.FluentDynamics.CreateDynamicProperty(System.Reflection.PropertyInfo)">
            <summary>
            Create a dynamic type representation of a property
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.FluentDynamics.CreateDynamicField(System.Reflection.FieldInfo)">
            <summary>
            Create a dynamic type representation of a property
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.FluentDynamics.GetVisibilityModifiers(System.Reflection.MethodBase)">
            <summary>
            Get the visibility modifiers of a method
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.FluentDynamics.GetVisibilityModifiers(System.Type)">
            <summary>
            Get the visibility modifiers of a type
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.FluentDynamics.GetVisibilityModifiers(System.Reflection.FieldInfo)">
            <summary>
            Get the visibility modifiers of a field
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.FluentDynamics.GetAccessModifiers(System.Reflection.MethodBase)">
            <summary>
            Get the access modifiers of a method
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.FluentDynamics.GetAccessModifiers(System.Type)">
            <summary>
            Get the access modifiers of a type
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Dynamics.FluentDynamics.GetAccessModifiers(System.Reflection.FieldInfo)">
            <summary>
            Get the access modifiers of a field
            </summary>
        </member>
        <member name="T:DotLogix.Core.Reflection.Dynamics.ValueAccessModes">
            <summary>
            Value accessing rights
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.ValueAccessModes.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.ValueAccessModes.Read">
            <summary>
            Read
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.ValueAccessModes.Write">
            <summary>
            Write
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.ValueAccessModes.ReadWrite">
            <summary>
            Read or Write
            </summary>
        </member>
        <member name="T:DotLogix.Core.Reflection.Dynamics.VisibilityModifiers">
            <summary>
            Visibility modifiers for type members
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.VisibilityModifiers.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.VisibilityModifiers.Private">
            <summary>
            Private
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.VisibilityModifiers.Protected">
            <summary>
            Protected
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.VisibilityModifiers.Internal">
            <summary>
            Internal
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.VisibilityModifiers.ProtectedInternal">
            <summary>
            Protected internal
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.VisibilityModifiers.Public">
            <summary>
            Public
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.VisibilityModifiers.NonPublic">
            <summary>
            NonePublic Mask
            </summary>
        </member>
        <member name="F:DotLogix.Core.Reflection.Dynamics.VisibilityModifiers.Any">
            <summary>
            Any
            </summary>
        </member>
        <member name="T:DotLogix.Core.Reflection.Fluent.FluentIl">
            <summary>
                A static class to create delegates
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.FluentIl.CreateInvoke(System.Reflection.MethodInfo,System.Boolean)">
            <summary>
                Creates a dynamic method to call a reflected method info with minimum overhead
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.FluentIl.CreateConstructor(System.Type,System.Reflection.ConstructorInfo,System.Boolean)">
            <summary>
                Creates a dynamic method to call a reflected constructor info with minimum overhead
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.FluentIl.CreateGetter(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>
                Creates a dynamic method to call a getter of a property info with minimum overhead
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.FluentIl.CreateSetter(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>
                Creates a dynamic method to call a setter of a property info with minimum overhead
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.FluentIl.CreateGetter``2(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>
                Creates a dynamic method to call a getter of a property info with minimum overhead
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.FluentIl.CreateSetter``2(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>
                Creates a dynamic method to call a setter of a property info with minimum overhead
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.FluentIl.CreateGetter(System.Reflection.FieldInfo,System.Boolean)">
            <summary>
                Creates a dynamic method to call a getter of a field info with minimum overhead
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.FluentIl.CreateSetter(System.Reflection.FieldInfo,System.Boolean)">
            <summary>
                Creates a dynamic method to call a setter of a field info with minimum overhead
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.FluentIl.CreateGetter``2(System.Reflection.FieldInfo,System.Boolean)">
            <summary>
                Creates a dynamic method to call a getter of a field info with minimum overhead
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.FluentIl.CreateSetter``2(System.Reflection.FieldInfo,System.Boolean)">
            <summary>
                Creates a dynamic method to call a setter of a field info with minimum overhead
            </summary>
        </member>
        <member name="T:DotLogix.Core.Reflection.Fluent.FluentIlExtensions">
            <summary>
            A static class providing extension methods for reflection
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.FluentIlExtensions.AsFluent(System.Reflection.Emit.ILGenerator)">
            <summary>
            Create a fluent implementation of an il generator
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.FluentIlExtensions.GetFluentIlGenerator(System.Reflection.Emit.DynamicMethod)">
            <summary>
            Create a fluent implementation of an il generator
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.FluentIlExtensions.GetFluentIlGenerator(System.Reflection.Emit.ConstructorBuilder)">
            <summary>
            Create a fluent implementation of an il generator
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.FluentIlExtensions.GetFluentIlGenerator(System.Reflection.Emit.MethodBuilder)">
            <summary>
            Create a fluent implementation of an il generator
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.FluentIlExtensions.GetFluentIlGenerator(System.Reflection.Emit.DynamicMethod,System.Int32)">
            <summary>
            Create a fluent implementation of an il generator
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.FluentIlExtensions.GetFluentIlGenerator(System.Reflection.Emit.ConstructorBuilder,System.Int32)">
            <summary>
            Create a fluent implementation of an il generator
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.FluentIlExtensions.GetFluentIlGenerator(System.Reflection.Emit.MethodBuilder,System.Int32)">
            <summary>
            Create a fluent implementation of an il generator
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.FluentIlExtensions.IsIndexerProperty(System.Reflection.PropertyInfo)">
            <summary>
            Checks if a property is an indexer
            </summary>
        </member>
        <member name="T:DotLogix.Core.Reflection.Fluent.FluentIlGeneratorExtensions">
            <summary>
            A static class providing extension methods for <see cref="T:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator"/>
            </summary>
        </member>
        <member name="T:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator">
            <summary>
            A fluent il generator
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Newarr(System.Type)">
            <summary>
                Pushes an object reference to a new zero-based, one-dimensional array whose elements are of a specific type
                onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldlen">
            <summary>
                Pushes the number of elements of a zero-based, one-dimensional array onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldelem(System.Type)">
            <summary>
                Loads the element at a specified array index onto the top of the evaluation stack as the type specified in the
                instruction.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldelem_I">
            <summary>
                Loads the element with type native int at a specified array index onto the top of the evaluation stack as
                a native int.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldelem_I1">
            <summary>
                Loads the element with type int8 at a specified array index onto the top of the evaluation stack as an int32.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldelem_I2">
            <summary>
                Loads the element with type int16 at a specified array index onto the top of the evaluation stack as an int32.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldelem_I4">
            <summary>
                Loads the element with type int32 at a specified array index onto the top of the evaluation stack as an int32.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldelem_I8">
            <summary>
                Loads the element with type int64 at a specified array index onto the top of the evaluation stack as an int64.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldelem_R4">
            <summary>
                Loads the element with type float32 at a specified array index onto the top of the evaluation stack as type
                F(float).
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldelem_R8">
            <summary>
                Loads the element with type float64 at a specified array index onto the top of the evaluation stack as type
                F(float).
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldelem_Ref">
            <summary>
                Loads the element containing an object reference at a specified array index onto the top of the evaluation
                stack as type O (object reference).
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldelem_U1">
            <summary>
                Loads the element with type unsigned int8 at a specified array index onto the top of the evaluation stack as
                an int32.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldelem_U2">
            <summary>
                Loads the element with type unsigned int16 at a specified array index onto the top of the evaluation stack as
                an int32.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldelem_U4">
            <summary>
                Loads the element with type unsigned int32 at a specified array index onto the top of the evaluation stack as
                an int32.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldelema(System.Type)">
            <summary>
                Loads the address of the array element at a specified array index onto the top of the evaluation stack as type
                &amp;(managed pointer).
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Stelem(System.Type)">
            <summary>
                Replaces the array element at a given index with the value on the evaluation stack, whose type is specified in
                the instruction.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Stelem_I">
            <summary>
                Replaces the array element at a given index with the native int value on the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Stelem_I1">
            <summary>
                Replaces the array element at a given index with the int8 value on the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Stelem_I2">
            <summary>
                Replaces the array element at a given index with the int16 value on the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Stelem_I4">
            <summary>
                Replaces the array element at a given index with the int32 value on the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Stelem_I8">
            <summary>
                Replaces the array element at a given index with the int64 value on the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Stelem_R4">
            <summary>
                Replaces the array element at a given index with the float32 value on the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Stelem_R8">
            <summary>
                Replaces the array element at a given index with the float64 value on the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Stelem_Ref">
            <summary>
                Replaces the array element at a given index with the object ref value (type O) on the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.And">
            <summary>
                Computes the bitwise AND of two values and pushes the result onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Nand">
            <summary>
                Computes the bitwise NAND of two values and pushes the result onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Xor">
            <summary>
                Computes the bitwise XOR of the top two values on the evaluation stack, pushing the result onto the evaluation
                stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Xnor">
            <summary>
                Computes the bitwise XNOR of the top two values on the evaluation stack, pushing the result onto the evaluation
                stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Or">
            <summary>
                Computes the bitwise OR of two values and pushes the result onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Nor">
            <summary>
                Computes the bitwise NOR of two values and pushes the result onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Not">
            <summary>
                Inverts the top value on the evaluation stack, pushing the result onto the evaluation
                stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ceq">
            <summary>
                Compares two values. If they are equal, the integer value 1 (int32) is pushed onto the evaluation stack;
                otherwise 0 (int32) is pushed onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Cgt">
            <summary>
                Compares two values. If the first value is greater than the second, the integer value 1 (int32) is pushed onto
                the evaluation stack; otherwise 0 (int32) is pushed onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Cgt_Un">
            <summary>
                Compares two unsigned or unordered values. If the first value is greater than the second, the integer value 1
                (int32) is pushed onto the evaluation stack; otherwise 0 (int32) is pushed onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Clt">
            <summary>
                Compares two values. If the first value is less than the second, the integer value 1 (int32) is pushed onto
                the evaluation stack; otherwise 0 (int32) is pushed onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Clt_Un">
            <summary>
                Compares the unsigned or unordered values value1 and value2. If value1 is less than value2, then the integer
                value 1 (int32) is pushed onto the evaluation stack; otherwise 0 (int32) is pushed onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ckfinite">
            <summary>
                Throws ArithmeticException if value is not a finite number.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Jmp(System.Reflection.MethodInfo)">
            <summary>
                Exits current method and jumps to specified method.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Switch(System.Reflection.Emit.Label[])">
            <summary>
                Implements a jump table.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Endfilter">
            <summary>
                Transfers control from the filter clause of an exception back to the Common Language Infrastructure (CLI)
                exception handler.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Endfinally">
            <summary>
                Transfers control from the fault or finally clause of an exception block back to the Common Language
                Infrastructure (CLI) exception handler.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Leave(System.Reflection.Emit.Label)">
            <summary>
                Exits a protected region of code, unconditionally transferring control to a specific target instruction.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Leave_S(System.Reflection.Emit.Label)">
            <summary>
                Exits a protected region of code, unconditionally transferring control to a target instruction (short form).
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Beq(System.Reflection.Emit.Label)">
            <summary>
                Transfers control to a target instruction if two values are equal.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Beq_S(System.Reflection.Emit.Label)">
            <summary>
                Transfers control to a target instruction (short form) if two values are equal.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Bge(System.Reflection.Emit.Label)">
            <summary>
                Transfers control to a target instruction if the first value is greater than or equal to the second value.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Bge_S(System.Reflection.Emit.Label)">
            <summary>
                Transfers control to a target instruction (short form) if the first value is greater than or equal to the
                second value.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Bge_Un(System.Reflection.Emit.Label)">
            <summary>
                Transfers control to a target instruction if the first value is greater than the second value, when comparing
                unsigned integer values or unordered float values.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Bge_Un_S(System.Reflection.Emit.Label)">
            <summary>
                Transfers control to a target instruction (short form) if the first value is greater than the second value,
                when comparing unsigned integer values or unordered float values.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Bgt(System.Reflection.Emit.Label)">
            <summary>
                Transfers control to a target instruction if the first value is greater than the second value.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Bgt_S(System.Reflection.Emit.Label)">
            <summary>
                Transfers control to a target instruction (short form) if the first value is greater than the second value.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Bgt_Un(System.Reflection.Emit.Label)">
            <summary>
                Transfers control to a target instruction if the first value is greater than the second value, when comparing
                unsigned integer values or unordered float values.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Bgt_Un_S(System.Reflection.Emit.Label)">
            <summary>
                Transfers control to a target instruction (short form) if the first value is greater than the second value,
                when comparing unsigned integer values or unordered float values.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ble(System.Reflection.Emit.Label)">
            <summary>
                Transfers control to a target instruction if the first value is less than or equal to the second value.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ble_S(System.Reflection.Emit.Label)">
            <summary>
                Transfers control to a target instruction (short form) if the first value is less than or equal to the second
                value.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ble_Un(System.Reflection.Emit.Label)">
            <summary>
                Transfers control to a target instruction if the first value is less than or equal to the second value, when
                comparing unsigned integer values or unordered float values.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ble_Un_S(System.Reflection.Emit.Label)">
            <summary>
                Transfers control to a target instruction (short form) if the first value is less than or equal to the second
                value, when comparing unsigned integer values or unordered float values.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Blt(System.Reflection.Emit.Label)">
            <summary>
                Transfers control to a target instruction if the first value is less than the second value.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Blt_S(System.Reflection.Emit.Label)">
            <summary>
                Transfers control to a target instruction (short form) if the first value is less than the second value.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Blt_Un(System.Reflection.Emit.Label)">
            <summary>
                Transfers control to a target instruction if the first value is less than the second value, when comparing
                unsigned integer values or unordered float values.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Blt_Un_S(System.Reflection.Emit.Label)">
            <summary>
                Transfers control to a target instruction (short form) if the first value is less than the second value, when
                comparing unsigned integer values or unordered float values.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Bne_Un(System.Reflection.Emit.Label)">
            <summary>
                Transfers control to a target instruction when two unsigned integer values or unordered float values are not
                equal.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Bne_Un_S(System.Reflection.Emit.Label)">
            <summary>
                Transfers control to a target instruction (short form) when two unsigned integer values or unordered float
                values are not equal.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Br(System.Reflection.Emit.Label)">
            <summary>
                Unconditionally transfers control to a target instruction.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Br_S(System.Reflection.Emit.Label)">
            <summary>
                Unconditionally transfers control to a target instruction (short form).
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Break">
            <summary>
                Signals the Common Language Infrastructure (CLI) to inform the debugger that a break point has been tripped.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Brfalse(System.Reflection.Emit.Label)">
            <summary>
                Transfers control to a target instruction if value is false, a null reference (Nothing in Visual Basic), or
                zero.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Brfalse_S(System.Reflection.Emit.Label)">
            <summary>
                Transfers control to a target instruction if value is false, a null reference, or zero.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Brtrue(System.Reflection.Emit.Label)">
            <summary>
                Transfers control to a target instruction if value is true, not null, or non-zero.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Brtrue_S(System.Reflection.Emit.Label)">
            <summary>
                Transfers control to a target instruction (short form) if value is true, not null, or non-zero.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_I">
            <summary>
                Converts the value on top of the evaluation stack to native int.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_I1">
            <summary>
                Converts the value on top of the evaluation stack to int8, then extends (pads) it to int32.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_I2">
            <summary>
                Converts the value on top of the evaluation stack to int16, then extends (pads) it to int32.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_I4">
            <summary>
                Converts the value on top of the evaluation stack to int32.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_I8">
            <summary>
                Converts the value on top of the evaluation stack to int64.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_Ovf_I">
            <summary>
                Converts the signed value on top of the evaluation stack to signed native int, throwing OverflowException on
                overflow.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_Ovf_I_Un">
            <summary>
                Converts the unsigned value on top of the evaluation stack to signed native int, throwing OverflowException on
                overflow.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_Ovf_I1">
            <summary>
                Converts the signed value on top of the evaluation stack to signed int8 and extends it to int32, throwing
                OverflowException on overflow.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_Ovf_I1_Un">
            <summary>
                Converts the unsigned value on top of the evaluation stack to signed int8 and extends it to int32, throwing
                OverflowException on overflow.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_Ovf_I2">
            <summary>
                Converts the signed value on top of the evaluation stack to signed int16 and extending it to int32, throwing
                OverflowException on overflow.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_Ovf_I2_Un">
            <summary>
                Converts the unsigned value on top of the evaluation stack to signed int16 and extends it to int32, throwing
                OverflowException on overflow.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_Ovf_I4">
            <summary>
                Converts the signed value on top of the evaluation stack to signed int32, throwing OverflowException on
                overflow.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_Ovf_I4_Un">
            <summary>
                Converts the unsigned value on top of the evaluation stack to signed int32, throwing OverflowException on
                overflow.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_Ovf_I8">
            <summary>
                Converts the signed value on top of the evaluation stack to signed int64, throwing OverflowException on
                overflow.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_Ovf_I8_Un">
            <summary>
                Converts the unsigned value on top of the evaluation stack to signed int64, throwing OverflowException on
                overflow.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_Ovf_U">
            <summary>
                Converts the signed value on top of the evaluation stack to unsigned native int, throwing OverflowExceptionon
                overflow.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_Ovf_U_Un">
            <summary>
                Converts the unsigned value on top of the evaluation stack to unsigned native int, throwing
                OverflowExceptionon overflow.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_Ovf_U1">
            <summary>
                Converts the signed value on top of the evaluation stack to unsigned int8 and extends it to int32, throwing
                OverflowException on overflow.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_Ovf_U1_Un">
            <summary>
                Converts the unsigned value on top of the evaluation stack to unsigned int8 and extends it to int32, throwing
                OverflowException on overflow.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_Ovf_U2">
            <summary>
                Converts the signed value on top of the evaluation stack to unsigned int16 and extends it to int32, throwing
                OverflowException on overflow.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_Ovf_U2_Un">
            <summary>
                Converts the unsigned value on top of the evaluation stack to unsigned int16 and extends it to int32, throwing
                OverflowException on overflow.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_Ovf_U4">
            <summary>
                Converts the signed value on top of the evaluation stack to unsigned int32, throwing OverflowException on
                overflow.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_Ovf_U4_Un">
            <summary>
                Converts the unsigned value on top of the evaluation stack to unsigned int32, throwing OverflowException on
                overflow.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_Ovf_U8">
            <summary>
                Converts the signed value on top of the evaluation stack to unsigned int64, throwing OverflowException on
                overflow.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_Ovf_U8_Un">
            <summary>
                Converts the unsigned value on top of the evaluation stack to unsigned int64, throwing OverflowException on
                overflow.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_R_Un">
            <summary>
                Converts the unsigned integer value on top of the evaluation stack to float32.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_R4">
            <summary>
                Converts the value on top of the evaluation stack to float32.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_R8">
            <summary>
                Converts the value on top of the evaluation stack to float64.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_U">
            <summary>
                Converts the value on top of the evaluation stack to unsigned native int, and extends it to native int.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_U1">
            <summary>
                Converts the value on top of the evaluation stack to unsigned int8, and extends it to int32.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_U2">
            <summary>
                Converts the value on top of the evaluation stack to unsigned int16, and extends it to int32.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_U4">
            <summary>
                Converts the value on top of the evaluation stack to unsigned int32, and extends it to int32.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Conv_U8">
            <summary>
                Converts the value on top of the evaluation stack to unsigned int64, and extends it to int64.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Box(System.Type)">
            <summary>
                Converts a value type to an object reference (type O).
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Unbox(System.Type)">
            <summary>
                Converts the boxed representation of a value type to its unboxed form.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Unbox_Any(System.Type)">
            <summary>
                Converts the boxed representation of a type specified in the instruction to its unboxed form.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Castclass(System.Type)">
            <summary>
                Attempts to cast an object passed by reference to the specified class.
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.IlGenerator">
            <summary>
                Get the IlGenerator
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.#ctor(System.Reflection.Emit.ILGenerator)">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator"/>
            </summary>
            <param name="ilGenerator"></param>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Cpblk">
            <summary>
                Copies a specified number bytes from a source address to a destination address.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Cpobj(System.Type)">
            <summary>
                Copies the value type located at the address of an object (type &amp;, * or native int) to the address of the
                destination object (type &amp;, * or native int).
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Dup">
            <summary>
                Copies the current topmost value on the evaluation stack, and then pushes the copy onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Initblk">
            <summary>
                Initializes a specified block of memory at a specific address to a given size and initial value.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Localloc">
            <summary>
                Allocates a certain number of bytes from the local dynamic memory pool and pushes the address (a transient
                pointer, type *) of the first allocated byte onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Rethrow">
            <summary>
                Rethrows the current exception.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Throw">
            <summary>
                Throws the exception object currently on the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Pop">
            <summary>
                Removes the value currently on top of the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Readonly">
            <summary>
                Specifies that the subsequent array address operation performs no type check at run time, and that it returns
                a managed pointer whose mutability is restricted.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Volatile">
            <summary>
                Specifies that an address currently atop the evaluation stack might be volatile, and the results of reading
                that location cannot be cached or that multiple stores to that location cannot be suppressed.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Tailcall">
            <summary>
                Performs a postfixed method call instruction such that the current method's stack frame is removed before the
                actual call instruction is executed.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Unaligned(System.Reflection.Emit.Label)">
            <summary>
                Indicates that an address currently atop the evaluation stack might not be aligned to the natural size of the
                immediately following ldind, stind, ldfld, stfld, ldobj, stobj, initblk, or cpblk instruction.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Unaligned(System.Byte)">
            <summary>
                Indicates that an address currently atop the evaluation stack might not be aligned to the natural size of the
                immediately following ldind, stind, ldfld, stfld, ldobj, stobj, initblk, or cpblk instruction.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Sizeof(System.Type)">
            <summary>
                Pushes the size, in bytes, of a supplied value type onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Nop">
            <summary>
                Fills space if opcodes are patched. No meaningful operation is performed although a processing cycle can be
                consumed.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldtoken(System.Reflection.MethodInfo)">
            <summary>
                Converts a metadata token to its runtime representation, pushing it onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldtoken(System.Reflection.FieldInfo)">
            <summary>
                Converts a metadata token to its runtime representation, pushing it onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldtoken(System.Type)">
            <summary>
                Converts a metadata token to its runtime representation, pushing it onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldftn(System.Reflection.MethodInfo)">
            <summary>
                Pushes an unmanaged pointer (type native int) to the native code implementing a specific method onto the
                evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldvirtftn(System.Reflection.MethodInfo)">
            <summary>
                Pushes an unmanaged pointer (type native int) to the native code implementing a particular virtual method
                associated with a specified object onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Mkrefany(System.Type)">
            <summary>
                Pushes a typed reference to a new instance of a specific type onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Refanytype">
            <summary>
                Retrieves the type token embedded in a typed reference.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Refanyval(System.Type)">
            <summary>
                Retrieves the address (type &amp;) embedded in a typed reference.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldfld(System.Reflection.FieldInfo)">
            <summary>
                Finds the value of a field in the object whose reference is currently on the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldflda(System.Reflection.FieldInfo)">
            <summary>
                Finds the address of a field in the object whose reference is currently on the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldsfld(System.Reflection.FieldInfo)">
            <summary>
                Pushes the value of a static field onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldsflda(System.Reflection.FieldInfo)">
            <summary>
                Pushes the address of a static field onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Stfld(System.Reflection.FieldInfo)">
            <summary>
                Replaces the value stored in the field of an object reference or pointer with a new value.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Stsfld(System.Reflection.FieldInfo)">
            <summary>
                Replaces the value of a static field with a value from the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Stind_I">
            <summary>
                Stores a value of type native int at a supplied address.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Stind_I1">
            <summary>
                Stores a value of type int8 at a supplied address.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Stind_I2">
            <summary>
                Stores a value of type int16 at a supplied address.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Stind_I4">
            <summary>
                Stores a value of type int32 at a supplied address.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Stind_I8">
            <summary>
                Stores a value of type int64 at a supplied address.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Stind_R4">
            <summary>
                Stores a value of type float32 at a supplied address.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Stind_R8">
            <summary>
                Stores a value of type float64 at a supplied address.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Stind_Ref">
            <summary>
                Stores a object reference value at a supplied address.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldind_I">
            <summary>
                Loads a value of type native int as a native int onto the evaluation stack indirectly.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldind_I1">
            <summary>
                Loads a value of type int8 as an int32 onto the evaluation stack indirectly.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldind_I2">
            <summary>
                Loads a value of type int16 as an int32 onto the evaluation stack indirectly.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldind_I4">
            <summary>
                Loads a value of type int32 as an int32 onto the evaluation stack indirectly.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldind_I8">
            <summary>
                Loads a value of type int64 as an int64 onto the evaluation stack indirectly.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldind_R4">
            <summary>
                Loads a value of type float32 as a type F (float) onto the evaluation stack indirectly.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldind_R8">
            <summary>
                Loads a value of type float64 as a type F (float) onto the evaluation stack indirectly.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldind_Ref">
            <summary>
                Loads an object reference as a type O (object reference) onto the evaluation stack indirectly.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldind_U1">
            <summary>
                Loads a value of type unsigned int8 as an int32 onto the evaluation stack indirectly.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldind_U2">
            <summary>
                Loads a value of type unsigned int16 as an int32 onto the evaluation stack indirectly.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldind_U4">
            <summary>
                Loads a value of type unsigned int32 as an int32 onto the evaluation stack indirectly.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldloc(System.Int16)">
            <summary>
                Loads the local variable at a specific index onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldloc(System.Reflection.Emit.LocalBuilder)">
            <summary>
                Loads the local variable at a specific index onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldloc_0">
            <summary>
                Loads the local variable at index 0 onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldloc_1">
            <summary>
                Loads the local variable at index 1 onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldloc_2">
            <summary>
                Loads the local variable at index 2 onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldloc_3">
            <summary>
                Loads the local variable at index 3 onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldloc_S(System.Byte)">
            <summary>
                Loads the local variable at a specific index onto the evaluation stack, short form.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldloc_S(System.Reflection.Emit.LocalBuilder)">
            <summary>
                Loads the local variable at a specific index onto the evaluation stack, short form.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldloca(System.Int16)">
            <summary>
                Loads the address of the local variable at a specific index onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldloca(System.Reflection.Emit.LocalBuilder)">
            <summary>
                Loads the address of the local variable at a specific index onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldloca_S(System.Byte)">
            <summary>
                Loads the address of the local variable at a specific index onto the evaluation stack, short form.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldloca_S(System.Reflection.Emit.LocalBuilder)">
            <summary>
                Loads the address of the local variable at a specific index onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Stloc(System.Int16)">
            <summary>
                Pops the current value from the top of the evaluation stack and stores it in a the local variable list at a
                specified index.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Stloc(System.Reflection.Emit.LocalBuilder)">
            <summary>
                Pops the current value from the top of the evaluation stack and stores it in a the local variable list at a
                specified index.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Stloc_0">
            <summary>
                Pops the current value from the top of the evaluation stack and stores it in a the local variable list at
                index 0.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Stloc_1">
            <summary>
                Pops the current value from the top of the evaluation stack and stores it in a the local variable list at
                index 1.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Stloc_2">
            <summary>
                Pops the current value from the top of the evaluation stack and stores it in a the local variable list at
                index 2.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Stloc_3">
            <summary>
                Pops the current value from the top of the evaluation stack and stores it in a the local variable list at
                index 3.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Stloc_S(System.Byte)">
            <summary>
                Pops the current value from the top of the evaluation stack and stores it in a the local variable list at
                index (short form).
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Stloc_S(System.Reflection.Emit.LocalBuilder)">
            <summary>
                Pops the current value from the top of the evaluation stack and stores it in a the local variable list at
                index (short form).
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Shl">
            <summary>
                Shifts an integer value to the left (in zeroes) by a specified number of bits, pushing the result onto the
                evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Shr">
            <summary>
                Shifts an integer value (in sign) to the right by a specified number of bits, pushing the result onto the
                evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Shr_Un">
            <summary>
                Shifts an unsigned integer value (in zeroes) to the right by a specified number of bits, pushing the result
                onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Rem">
            <summary>
                Divides two values and pushes the remainder onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Rem_Un">
            <summary>
                Divides two unsigned values and pushes the remainder onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Sub">
            <summary>
                Subtracts one value from another and pushes the result onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Sub_Ovf">
            <summary>
                Subtracts one integer value from another, performs an overflow check, and pushes the result onto the
                evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Sub_Ovf_Un">
            <summary>
                Subtracts one unsigned integer value from another, performs an overflow check, and pushes the result onto the
                evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Add">
            <summary>
                Adds two values and pushes the result onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Add_Ovf">
            <summary>
                Adds two integers, performs an overflow check, and pushes the result onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Add_Ovf_Un">
            <summary>
                Adds two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Div">
            <summary>
                Divides two values and pushes the result as a floating-point (type F) or quotient (type int32) onto the
                evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Div_Un">
            <summary>
                Divides two unsigned integer values and pushes the result (int32) onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Mul">
            <summary>
                Multiplies two values and pushes the result on the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Mul_Ovf">
            <summary>
                Multiplies two integer values, performs an overflow check, and pushes the result onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Mul_Ovf_Un">
            <summary>
                Multiplies two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation
                stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Neg">
            <summary>
                Negates a value and pushes the result onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Constrained(System.Type)">
            <summary>
                Constrains the type on which a virtual method call is made.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Call(System.Reflection.MethodInfo)">
            <summary>
                Calls the method indicated by the passed method descriptor.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Call(System.Reflection.MethodInfo,System.Type[])">
            <summary>
                Calls the method indicated by the passed method descriptor.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Calli(System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[])">
            <summary>
                Calls the method indicated on the evaluation stack (as a pointer to an entry point) with arguments described
                by a calling convention.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Callvirt(System.Reflection.MethodInfo)">
            <summary>
                Calls a late-bound method on an object, pushing the return value onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Callvirt(System.Reflection.MethodInfo,System.Type[])">
            <summary>
                Calls a late-bound method on an object, pushing the return value onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldarg(System.Int16)">
            <summary>
                Loads an argument (referenced by a specified index value) onto the stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldarg_0">
            <summary>
                Loads the argument at index 0 onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldarg_1">
            <summary>
                Loads the argument at index 1 onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldarg_2">
            <summary>
                Loads the argument at index 2 onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldarg_3">
            <summary>
                Loads the argument at index 3 onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldarg_S(System.Byte)">
            <summary>
                Loads the argument (referenced by a specified short form index) onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldarga(System.Int16)">
            <summary>
                Load an argument address onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldarga_S(System.Byte)">
            <summary>
                Load an argument address, in short form, onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Starg_S(System.Byte)">
            <summary>
                Stores the value on top of the evaluation stack in the argument slot at a specified index, short form.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Starg(System.Int16)">
            <summary>
                Stores the value on top of the evaluation stack in the argument slot at a specified index.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Arglist">
            <summary>
                Returns an unmanaged pointer to the argument list of the current method.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ret">
            <summary>
                Returns from the current method, pushing a return value (if present) from the callee's evaluation stack onto
                the caller's evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldobj(System.Type)">
            <summary>
                Copies the value type object pointed to by an address to the top of the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Initobj(System.Type)">
            <summary>
                Initializes each field of the value type at a specified address to a null reference or a 0 of the appropriate
                primitive type.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Newobj(System.Reflection.ConstructorInfo)">
            <summary>
                Creates a new object or a new instance of a value type, pushing an object reference (type O) onto the
                evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Stobj(System.Type)">
            <summary>
                Copies a value of a specified type from the evaluation stack into a supplied memory address.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Isinst(System.Type)">
            <summary>
                Tests whether an object reference (type O) is a new instance of a particular class.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldnull">
            <summary>
                Pushes a null reference (type O) onto the evaluation stack.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldstr(System.String)">
            <summary>
                Pushes a new object reference to a string literal stored in the metadata.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldc_I4(System.Int32)">
            <summary>
                Pushes a supplied value of type int32 onto the evaluation stack as an int32.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldc_I4_0">
            <summary>
                Pushes the integer value of 0 onto the evaluation stack as an int32.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldc_I4_1">
            <summary>
                Pushes the integer value of 1 onto the evaluation stack as an int32.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldc_I4_2">
            <summary>
                Pushes the integer value of 2 onto the evaluation stack as an int32.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldc_I4_3">
            <summary>
                Pushes the integer value of 3 onto the evaluation stack as an int32.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldc_I4_4">
            <summary>
                Pushes the integer value of 4 onto the evaluation stack as an int32.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldc_I4_5">
            <summary>
                Pushes the integer value of 5 onto the evaluation stack as an int32.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldc_I4_6">
            <summary>
                Pushes the integer value of 6 onto the evaluation stack as an int32.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldc_I4_7">
            <summary>
                Pushes the integer value of 7 onto the evaluation stack as an int32.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldc_I4_8">
            <summary>
                Pushes the integer value of 8 onto the evaluation stack as an int32.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldc_I4_M1">
            <summary>
                Pushes the integer value of -1 onto the evaluation stack as an int32.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldc_I4_S(System.SByte)">
            <summary>
                Pushes the supplied int8 value onto the evaluation stack as an int32, short form.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldc_I8(System.Int64)">
            <summary>
                Pushes a supplied value of type int64 onto the evaluation stack as an int64.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldc_R4(System.Single)">
            <summary>
                Pushes a supplied value of type float32 onto the evaluation stack as type F (float).
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Fluent.Generator.FluentIlGenerator.Ldc_R8(System.Double)">
            <summary>
                Pushes a supplied value of type float64 onto the evaluation stack as type F (float).
            </summary>
        </member>
        <member name="T:DotLogix.Core.Reflection.Projections.CreateProjectionsCallback">
            <summary>
            A delegate to create projections from two types
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.Reflection.Projections.EqualityCheckProjection">
            <summary>
            A projection of two value accessors including an equality check
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Projections.EqualityCheckProjection.#ctor(DotLogix.Core.Reflection.Delegates.GetterDelegate,DotLogix.Core.Reflection.Delegates.GetterDelegate,DotLogix.Core.Reflection.Delegates.SetterDelegate,DotLogix.Core.Reflection.Delegates.SetterDelegate)">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Reflection.Projections.EqualityCheckProjection"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Projections.EqualityCheckProjection.ProjectLeftToRight(System.Object,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Reflection.Projections.EqualityCheckProjection.ProjectRightToLeft(System.Object,System.Object)">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Reflection.Projections.EqualityCheckProjectionFactory">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Reflection.Projections.EqualityCheckProjectionFactory.CreateProjection(DotLogix.Core.Reflection.Delegates.GetterDelegate,DotLogix.Core.Reflection.Delegates.GetterDelegate,DotLogix.Core.Reflection.Delegates.SetterDelegate,DotLogix.Core.Reflection.Delegates.SetterDelegate)">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Reflection.Projections.IProjection">
            <summary>
            An interface for object to object projections
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Projections.IProjection.ProjectLeftToRight(System.Object,System.Object)">
            <summary>
            Project the left object to the right
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Projections.IProjection.ProjectRightToLeft(System.Object,System.Object)">
            <summary>
            Project the right object to the left
            </summary>
        </member>
        <member name="T:DotLogix.Core.Reflection.Projections.IProjectionFactory">
            <summary>
            An interface for a factory producing projections
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Projections.IProjectionFactory.CreateProjections(System.Type,System.Type)">
            <summary>
            Create the projections to map the types
            </summary>
        </member>
        <member name="T:DotLogix.Core.Reflection.Projections.OptionalProjection">
            <summary>
            A projection of two value accessors including an equality check
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Projections.OptionalProjection.#ctor(DotLogix.Core.Reflection.Delegates.GetterDelegate,DotLogix.Core.Reflection.Delegates.GetterDelegate,DotLogix.Core.Reflection.Delegates.SetterDelegate,DotLogix.Core.Reflection.Delegates.SetterDelegate)">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Reflection.Projections.OptionalProjection"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Projections.OptionalProjection.ProjectLeftToRight(System.Object,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Reflection.Projections.OptionalProjection.ProjectRightToLeft(System.Object,System.Object)">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Reflection.Projections.OptionalProjectionFactory">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Reflection.Projections.OptionalProjectionFactory.CreateProjection(DotLogix.Core.Reflection.Delegates.GetterDelegate,DotLogix.Core.Reflection.Delegates.GetterDelegate,DotLogix.Core.Reflection.Delegates.SetterDelegate,DotLogix.Core.Reflection.Delegates.SetterDelegate)">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Reflection.Projections.Projection">
            <summary>
            A projection of two value accessors
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Projections.Projection.LeftGetter">
            <summary>
            The getter from the left side
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Projections.Projection.RightGetter">
            <summary>
            The getter from the right side
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Projections.Projection.LeftSetter">
            <summary>
            The setter from the left side
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Projections.Projection.RightSetter">
            <summary>
            The setter from the right side
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Projections.Projection.#ctor(DotLogix.Core.Reflection.Delegates.GetterDelegate,DotLogix.Core.Reflection.Delegates.GetterDelegate,DotLogix.Core.Reflection.Delegates.SetterDelegate,DotLogix.Core.Reflection.Delegates.SetterDelegate)">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Reflection.Projections.Projection"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Projections.Projection.ProjectLeftToRight(System.Object,System.Object)">
            <summary>
            Project the left object to the right
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Projections.Projection.ProjectRightToLeft(System.Object,System.Object)">
            <summary>
            Project the right object to the left
            </summary>
        </member>
        <member name="T:DotLogix.Core.Reflection.Projections.ProjectionFactory">
            <summary>
            A factory to produce projectsions
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Projections.ProjectionFactory.Auto">
            <summary>
            Try to map as many properties as possible
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Projections.ProjectionFactory.AutoWithEqualityCheck">
            <summary>
            Try to map as many properties as possible and as little as necessary include an equality check before assignment
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Projections.ProjectionFactory.AutoOptional">
            <summary>
            Try to map as many properties as possible and undefined <see cref="T:DotLogix.Core.Optional`1"/> are ignored include an equality check before assignment
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Projections.ProjectionFactory.#ctor">
            <summary>
            Create a new instance of <see cref="T:DotLogix.Core.Reflection.Projections.ProjectionFactory"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Projections.ProjectionFactory.CreateProjections(System.Type,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Reflection.Projections.ProjectionFactory.CreateProjection(DotLogix.Core.Reflection.Delegates.GetterDelegate,DotLogix.Core.Reflection.Delegates.GetterDelegate,DotLogix.Core.Reflection.Delegates.SetterDelegate,DotLogix.Core.Reflection.Delegates.SetterDelegate)">
            <summary>
            Create a new projection
            </summary>
        </member>
        <member name="T:DotLogix.Core.Reflection.Projections.TypeProjector">
            <summary>
            A type to type projector
            </summary>
        </member>
        <member name="P:DotLogix.Core.Reflection.Projections.TypeProjector.Projections">
            <summary>
            The projections
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Projections.TypeProjector.#ctor(System.Type,System.Type,DotLogix.Core.Reflection.Projections.IProjectionFactory)">
            <summary>
            Create a new instance of <see cref="T:DotLogix.Core.Reflection.Projections.TypeProjector"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Projections.TypeProjector.#ctor(System.Type,System.Type,DotLogix.Core.Reflection.Projections.CreateProjectionsCallback)">
            <summary>
            Create a new instance of <see cref="T:DotLogix.Core.Reflection.Projections.TypeProjector"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Projections.TypeProjector.ProjectLeftToRight(System.Object,System.Object)">
            <summary>
            Project the left object to the right
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Projections.TypeProjector.ProjectRightToLeft(System.Object,System.Object)">
            <summary>
            Project the right object to the left
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Projections.TypeProjector.Create(System.Type,System.Type,DotLogix.Core.Reflection.Projections.IProjectionFactory)">
            <summary>
            Create a new type projector
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Projections.TypeProjector.Create``2(DotLogix.Core.Reflection.Projections.IProjectionFactory)">
            <summary>
            Create a new type projector
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Projections.TypeProjector.Create(System.Type,System.Type,DotLogix.Core.Reflection.Projections.CreateProjectionsCallback)">
            <summary>
            Create a new type projector
            </summary>
        </member>
        <member name="M:DotLogix.Core.Reflection.Projections.TypeProjector.Create``2(DotLogix.Core.Reflection.Projections.CreateProjectionsCallback)">
            <summary>
            Create a new type projector
            </summary>
        </member>
        <member name="T:DotLogix.Core.Security.EncryptedString">
            <summary>
            A safe representation of a string stored in undetectable unmanaged memory
            </summary>
        </member>
        <member name="P:DotLogix.Core.Security.EncryptedString.ClearText">
            <summary>
            Get the clear text
            </summary>
        </member>
        <member name="P:DotLogix.Core.Security.EncryptedString.Length">
            <summary>
            The length of the string
            </summary>
        </member>
        <member name="M:DotLogix.Core.Security.EncryptedString.#ctor(System.String)">
            <summary>
            Creates a new <see cref="T:DotLogix.Core.Security.EncryptedString"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Security.EncryptedString.#ctor">
            <summary>
            Creates a new <see cref="T:DotLogix.Core.Security.EncryptedString"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Security.EncryptedString.Equals(DotLogix.Core.Security.EncryptedString)">
            <summary>
            Checks if the plain text equals
            </summary>
        </member>
        <member name="M:DotLogix.Core.Security.EncryptedString.Equals(System.Object)">
            <summary>
            Checks if the plain text equals
            </summary>
        </member>
        <member name="M:DotLogix.Core.Security.EncryptedString.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Security.EncryptedString.SetClearText(System.String)">
            <summary>
            Replace the text with another
            </summary>
        </member>
        <member name="M:DotLogix.Core.Security.EncryptedString.ToClearText">
            <summary>
            Get the clear text
            </summary>
        </member>
        <member name="M:DotLogix.Core.Security.EncryptedString.ToObfuscatedString">
            <summary>
            Get an obfuscated representation of the string
            </summary>
        </member>
        <member name="M:DotLogix.Core.Security.EncryptedString.ToEncryptedString">
            <summary>
            Get an encrypted representation of the string using a random guid as key.<br></br>
            The string can be decoded with this class as well.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Security.EncryptedString.GetBytes">
            <summary>
            Get the utf-8 bytes of the string
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Security.EncryptedString.ToSecureString">
            <summary>
            Get a secure string out of this encrypted string
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Security.EncryptedString.FromClearText(System.String)">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Security.EncryptedString"/> using the plain text
            </summary>
        </member>
        <member name="M:DotLogix.Core.Security.EncryptedString.FromObfuscatedString(System.String)">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Security.EncryptedString"/> using the obfuscated representation
            </summary>
        </member>
        <member name="M:DotLogix.Core.Security.EncryptedString.FromEncryptedString(System.String)">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Security.EncryptedString"/> using the encrypted representation
            </summary>
        </member>
        <member name="T:DotLogix.Core.Security.EncryptedStringConverter">
            <summary>
            A type converter to convert encrypted strings
            </summary>
        </member>
        <member name="M:DotLogix.Core.Security.EncryptedStringConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Security.EncryptedStringConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Security.EncryptedStringConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Security.EncryptedStringConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Security.EncryptedStringConverter.IsValid(System.ComponentModel.ITypeDescriptorContext,System.Object)">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Security.Encryption">
            <summary>
                encrypt and decrypt strings
            </summary>
        </member>
        <member name="M:DotLogix.Core.Security.Encryption.ObfuscateXor(System.Byte[])">
            <summary>
                Obfuscates an array of bytes with an XOr-Algorithm
            </summary>
            <param name="clearBytes">The clear bytes</param>
            <returns>A new array of obfuscated bytes</returns>
        </member>
        <member name="M:DotLogix.Core.Security.Encryption.UnobfuscateXor(System.Byte[])">
            <summary>
                Unobfuscates an array of obfuscated bytes with an XOr-Algorithm
            </summary>
            <param name="obfuscatedBytes">The obfuscated bytes</param>
            <returns>A new array of clear bytes</returns>
        </member>
        <member name="M:DotLogix.Core.Security.Encryption.ObfuscateXor(System.String)">
            <summary>
                Obfuscates a clear string with an XOr-Algorithm
            </summary>
            <param name="clearText">The clear text</param>
            <returns>A new obfuscated string in base64 format</returns>
        </member>
        <member name="M:DotLogix.Core.Security.Encryption.UnobfuscateXor(System.String)">
            <summary>
                Unbfuscates a base64 formatted obfuscated string with an XOr-Algorithm
            </summary>
            <param name="obfuscatedText">The obfuscated text</param>
            <returns>A new clear string</returns>
        </member>
        <member name="M:DotLogix.Core.Security.Encryption.EncryptAes(System.Byte[],System.Byte[],System.Int32)">
            <summary>
                Encrypts the data.
            </summary>
            <param name="clearBytes">The clear bytes</param>
            <param name="password">The password bytes</param>
            <param name="iterations">The iterations of the algorithm</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Security.Encryption.DecryptAes(System.Byte[],DotLogix.Core.Security.EncryptedString,System.Int32)">
            <summary>
                Decrypts the data.
            </summary>
            <param name="encryptedBytes">The clear bytes</param>
            <param name="password">The password bytes</param>
            <param name="iterations">The iterations of the algorithm</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Security.Encryption.EncryptAes(System.Byte[],DotLogix.Core.Security.EncryptedString,System.Int32)">
            <summary>
                Encrypts the data.
            </summary>
            <param name="clearBytes">The clear bytes</param>
            <param name="password">The password bytes</param>
            <param name="iterations">The iterations of the algorithm</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Security.Encryption.DecryptAes(System.Byte[],System.Byte[],System.Int32)">
            <summary>
                Decrypts the data.
            </summary>
            <param name="encryptedBytes">The clear bytes</param>
            <param name="password">The password bytes</param>
            <param name="iterations">The iterations of the algorithm</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Security.Encryption.EncryptAes(System.String,DotLogix.Core.Security.EncryptedString,System.Int32)">
            <summary>
                Encrypts the string.
            </summary>
            <param name="clearText">The clear text.</param>
            <param name="password">The password.</param>
            <param name="iterations">The iterations of the algorithm</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Security.Encryption.DecryptAes(System.String,DotLogix.Core.Security.EncryptedString,System.Int32)">
            <summary>
                Decrypts the string.
            </summary>
            <param name="encryptedText">The encrypted text.</param>
            <param name="password">The password.</param>
            <param name="iterations">The iterations of the algorithm</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Security.Encryption.EncryptAes(System.String,System.String,System.Int32)">
            <summary>
                Encrypts the string.
            </summary>
            <param name="clearText">The clear text.</param>
            <param name="password">The password.</param>
            <param name="iterations">The iterations of the algorithm</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Security.Encryption.DecryptAes(System.String,System.String,System.Int32)">
            <summary>
                Decrypts the string.
            </summary>
            <param name="encryptedText">The encrypted text.</param>
            <param name="password">The password.</param>
            <param name="iterations">The iterations of the algorithm</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Security.Encryption.EncryptAes(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
                Encrypts the string.
            </summary>
            <param name="clearBytes">The clear text.</param>
            <param name="key">The key.</param>
            <param name="iv">The IV.</param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Security.Encryption.DecryptAes(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
                Decrypts the string.
            </summary>
            <param name="encryptedBytes">The cipher data.</param>
            <param name="key">The key.</param>
            <param name="iv">The IV.</param>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.Tracking.ChangeTracker">
            <inheritdoc />
        </member>
        <member name="F:DotLogix.Core.Tracking.ChangeTracker.EntryManagers">
            <summary>
            The inner dictionary to hold data
            </summary>
        </member>
        <member name="P:DotLogix.Core.Tracking.ChangeTracker.Entries">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Tracking.ChangeTracker.MarkAsAdded(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Tracking.ChangeTracker.MarkAsDeleted(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Tracking.ChangeTracker.MarkAsModified(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Tracking.ChangeTracker.Attach(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Tracking.ChangeTracker.Detach(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Tracking.ChangeTracker.Entry(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Tracking.ChangeTracker.EnsureEntry(System.Object,System.Boolean)">
            <summary>
            Ensure an entry exists
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.ChangeTracker.EnsureEntryManager(System.Object)">
            <summary>
            Ensure an entry manager exists
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.ChangeTracker.CreateEntryManager(System.Type)">
            <summary>
            Create an entry manager
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.ChangeTracker.CreateSnapshotFactory(System.Type,System.Collections.Generic.List{DotLogix.Core.Reflection.Dynamics.DynamicAccessor})">
            <summary>
            Create a snapshot factory
            </summary>
        </member>
        <member name="T:DotLogix.Core.Tracking.Entries.ChangeTrackingEntry">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Tracking.Entries.ChangeTrackingEntry.#ctor(System.Object,DotLogix.Core.Tracking.Manager.IChangeTrackingEntryManager,DotLogix.Core.Tracking.Snapshots.ISnapshot,DotLogix.Core.Tracking.Entries.TrackedState)">
            <summary>
            Create a new instance of <see cref="T:DotLogix.Core.Tracking.Entries.ChangeTrackingEntry"/>
            </summary>
        </member>
        <member name="P:DotLogix.Core.Tracking.Entries.ChangeTrackingEntry.OldValues">
            <inheritdoc />
        </member>
        <member name="P:DotLogix.Core.Tracking.Entries.ChangeTrackingEntry.CurrentValues">
            <inheritdoc />
        </member>
        <member name="P:DotLogix.Core.Tracking.Entries.ChangeTrackingEntry.ChangedValues">
            <inheritdoc />
        </member>
        <member name="P:DotLogix.Core.Tracking.Entries.ChangeTrackingEntry.Key">
            <inheritdoc />
        </member>
        <member name="P:DotLogix.Core.Tracking.Entries.ChangeTrackingEntry.Target">
            <inheritdoc />
        </member>
        <member name="P:DotLogix.Core.Tracking.Entries.ChangeTrackingEntry.CurrentState">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Tracking.Entries.ChangeTrackingEntry.MarkAsAdded">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Tracking.Entries.ChangeTrackingEntry.MarkAsDeleted">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Tracking.Entries.ChangeTrackingEntry.MarkAsModified">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Tracking.Entries.ChangeTrackingEntry.Attach">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Tracking.Entries.ChangeTrackingEntry.Detach">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Tracking.Entries.ChangeTrackingEntry.RevertChanges">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Tracking.Entries.ChangeTrackingEntry.Reset">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Tracking.Entries.ChangeTrackingKeyAttribute">
            <summary>
            Set this property as key for change tracking index 
            </summary>
        </member>
        <member name="T:DotLogix.Core.Tracking.Entries.IChangeTrackingEntry">
            <summary>
            A change tracking entry
            </summary>
        </member>
        <member name="P:DotLogix.Core.Tracking.Entries.IChangeTrackingEntry.OldValues">
            <summary>
            The old values
            </summary>
        </member>
        <member name="P:DotLogix.Core.Tracking.Entries.IChangeTrackingEntry.ChangedValues">
            <summary>
            The changed values
            </summary>
        </member>
        <member name="P:DotLogix.Core.Tracking.Entries.IChangeTrackingEntry.CurrentValues">
            <summary>
            The current values
            </summary>
        </member>
        <member name="P:DotLogix.Core.Tracking.Entries.IChangeTrackingEntry.CurrentState">
            <summary>
            The current state
            </summary>
        </member>
        <member name="P:DotLogix.Core.Tracking.Entries.IChangeTrackingEntry.Key">
            <summary>
            The key
            </summary>
        </member>
        <member name="P:DotLogix.Core.Tracking.Entries.IChangeTrackingEntry.Target">
            <summary>
            The target
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.Entries.IChangeTrackingEntry.MarkAsAdded">
            <summary>
            Mark as added
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.Entries.IChangeTrackingEntry.MarkAsDeleted">
            <summary>
            Mark as deleted
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.Entries.IChangeTrackingEntry.MarkAsModified">
            <summary>
            Mark as modified
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.Entries.IChangeTrackingEntry.Attach">
            <summary>
            Detach self from entry manager
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.Entries.IChangeTrackingEntry.Detach">
            <summary>
            Detach self from entry manager
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.Entries.IChangeTrackingEntry.Reset">
            <summary>
            Accept all changes and return to unmodified state
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.Entries.IChangeTrackingEntry.RevertChanges">
            <summary>
            Revert all changes
            </summary>
        </member>
        <member name="T:DotLogix.Core.Tracking.Entries.IgnoreChangesAttribute">
            <summary>
            Don't track this property
            </summary>
        </member>
        <member name="T:DotLogix.Core.Tracking.Entries.TrackedState">
            <summary>
            The change tracking state of an entry
            </summary>
        </member>
        <member name="F:DotLogix.Core.Tracking.Entries.TrackedState.Detached">
            <summary>
            Detached
            </summary>
        </member>
        <member name="F:DotLogix.Core.Tracking.Entries.TrackedState.Unchanged">
            <summary>
            Unchanged
            </summary>
        </member>
        <member name="F:DotLogix.Core.Tracking.Entries.TrackedState.Modified">
            <summary>
            Modified
            </summary>
        </member>
        <member name="F:DotLogix.Core.Tracking.Entries.TrackedState.Added">
            <summary>
            Added
            </summary>
        </member>
        <member name="F:DotLogix.Core.Tracking.Entries.TrackedState.Deleted">
            <summary>
            Deleted
            </summary>
        </member>
        <member name="T:DotLogix.Core.Tracking.IChangeTracker">
            <summary>
            An interface for change tracking
            </summary>
        </member>
        <member name="P:DotLogix.Core.Tracking.IChangeTracker.Entries">
            <summary>
            The entries
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.IChangeTracker.MarkAsAdded(System.Object)">
            <summary>
            Mark an object as added
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.IChangeTracker.MarkAsDeleted(System.Object)">
            <summary>
            Mark an object as deleted
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.IChangeTracker.MarkAsModified(System.Object)">
            <summary>
            Mark an object as modified
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.IChangeTracker.Attach(System.Object)">
            <summary>
            Attach an object
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.IChangeTracker.Detach(System.Object)">
            <summary>
            Detach an object
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.IChangeTracker.Entry(System.Object)">
            <summary>
            Get the entry
            </summary>
        </member>
        <member name="T:DotLogix.Core.Tracking.Manager.ChangeTrackingEntryManager">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Tracking.Manager.ChangeTrackingEntryManager.#ctor(DotLogix.Core.Tracking.Snapshots.ISnapshotFactory,DotLogix.Core.Reflection.Dynamics.DynamicAccessor)">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Tracking.Manager.ChangeTrackingEntryManager"/>
            </summary>
        </member>
        <member name="P:DotLogix.Core.Tracking.Manager.ChangeTrackingEntryManager.Entries">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Tracking.Manager.ChangeTrackingEntryManager.GetEntry(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Tracking.Manager.ChangeTrackingEntryManager.TryGetEntry(System.Object,DotLogix.Core.Tracking.Entries.IChangeTrackingEntry@)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Tracking.Manager.ChangeTrackingEntryManager.EnsureEntry(System.Object,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Tracking.Manager.ChangeTrackingEntryManager.Add(DotLogix.Core.Tracking.Entries.IChangeTrackingEntry)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Tracking.Manager.ChangeTrackingEntryManager.Remove(DotLogix.Core.Tracking.Entries.IChangeTrackingEntry)">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Tracking.Manager.IChangeTrackingEntryManager">
            <summary>
            An interface for change tracking managers
            </summary>
        </member>
        <member name="P:DotLogix.Core.Tracking.Manager.IChangeTrackingEntryManager.Entries">
            <summary>
            The entries
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.Manager.IChangeTrackingEntryManager.GetEntry(System.Object)">
            <summary>
            Get a entry of a target value
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.Manager.IChangeTrackingEntryManager.EnsureEntry(System.Object,System.Boolean)">
            <summary>
            Ensure a entry for a target value
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.Manager.IChangeTrackingEntryManager.TryGetEntry(System.Object,DotLogix.Core.Tracking.Entries.IChangeTrackingEntry@)">
            <summary>
            Tries to get a entry of a target value
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.Manager.IChangeTrackingEntryManager.Add(DotLogix.Core.Tracking.Entries.IChangeTrackingEntry)">
            <summary>
            Add a entry to the manager
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.Manager.IChangeTrackingEntryManager.Remove(DotLogix.Core.Tracking.Entries.IChangeTrackingEntry)">
            <summary>
            Remove a entry to the manager
            </summary>
        </member>
        <member name="T:DotLogix.Core.Tracking.Snapshots.DiffSnapshot">
            <inheritdoc />
        </member>
        <member name="F:DotLogix.Core.Tracking.Snapshots.DiffSnapshot.TrackedValues">
            <summary>
            The tracked values
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.Snapshots.DiffSnapshot.#ctor(System.Object,System.Collections.Generic.IEnumerable{DotLogix.Core.Reflection.Dynamics.DynamicAccessor})">
            <summary>
            Create a new instance of <see cref="T:DotLogix.Core.Tracking.Snapshots.DiffSnapshot"/>
            </summary>
            <param name="target"></param>
            <param name="accessors"></param>
        </member>
        <member name="P:DotLogix.Core.Tracking.Snapshots.DiffSnapshot.Target">
            <inheritdoc />
        </member>
        <member name="P:DotLogix.Core.Tracking.Snapshots.DiffSnapshot.OldValues">
            <inheritdoc />
        </member>
        <member name="P:DotLogix.Core.Tracking.Snapshots.DiffSnapshot.CurrentValues">
            <inheritdoc />
        </member>
        <member name="P:DotLogix.Core.Tracking.Snapshots.DiffSnapshot.ChangedValues">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Tracking.Snapshots.DiffSnapshot.DetectChanges">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Tracking.Snapshots.DiffSnapshot.AcceptChanges">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Tracking.Snapshots.DiffSnapshot.RevertChanges">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Tracking.Snapshots.ISnapshot">
            <summary>
            A change tracking snapshot of an object
            </summary>
        </member>
        <member name="P:DotLogix.Core.Tracking.Snapshots.ISnapshot.Target">
            <summary>
            The target value
            </summary>
        </member>
        <member name="P:DotLogix.Core.Tracking.Snapshots.ISnapshot.OldValues">
            <summary>
            The old values
            </summary>
        </member>
        <member name="P:DotLogix.Core.Tracking.Snapshots.ISnapshot.CurrentValues">
            <summary>
            The current values
            </summary>
        </member>
        <member name="P:DotLogix.Core.Tracking.Snapshots.ISnapshot.ChangedValues">
            <summary>
            The changed values
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.Snapshots.ISnapshot.DetectChanges">
            <summary>
            Detect if a change has occured
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Tracking.Snapshots.ISnapshot.AcceptChanges">
            <summary>
            Accept changes
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.Snapshots.ISnapshot.RevertChanges">
            <summary>
            Revert changes
            </summary>
        </member>
        <member name="T:DotLogix.Core.Tracking.Snapshots.ISnapshotFactory">
            <summary>
            A factory to create snapshots
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.Snapshots.ISnapshotFactory.CreateSnapshot(System.Object)">
            <summary>
            Create a snapshot
            </summary>
        </member>
        <member name="T:DotLogix.Core.Tracking.Snapshots.DiffSnapshotFactory">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Tracking.Snapshots.DiffSnapshotFactory.#ctor(System.Collections.Generic.IEnumerable{DotLogix.Core.Reflection.Dynamics.DynamicAccessor})">
            <summary>
            Create a new instance of <see cref="T:DotLogix.Core.Tracking.Snapshots.DiffSnapshotFactory"/>
            </summary>
            <param name="accessors"></param>
        </member>
        <member name="M:DotLogix.Core.Tracking.Snapshots.DiffSnapshotFactory.CreateSnapshot(System.Object)">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Tracking.Snapshots.PropertyChangedSnapshotFactory">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Tracking.Snapshots.PropertyChangedSnapshotFactory.#ctor(System.Collections.Generic.IEnumerable{DotLogix.Core.Reflection.Dynamics.DynamicAccessor})">
            <summary>
            Create a new instance of <see cref="T:DotLogix.Core.Tracking.Snapshots.PropertyChangedSnapshotFactory"/>
            </summary>
            <param name="accessors"></param>
        </member>
        <member name="M:DotLogix.Core.Tracking.Snapshots.PropertyChangedSnapshotFactory.CreateSnapshot(System.Object)">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Tracking.Snapshots.PropertyChangedSnapshot">
            <inheritdoc />
        </member>
        <member name="P:DotLogix.Core.Tracking.Snapshots.PropertyChangedSnapshot.Target">
            <summary>
            The target value
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.Snapshots.PropertyChangedSnapshot.#ctor(System.ComponentModel.INotifyPropertyChanged,System.Collections.Generic.IEnumerable{DotLogix.Core.Reflection.Dynamics.DynamicAccessor})">
            <summary>Initialisiert eine neue Instanz der <see cref="T:System.Object" />-Klasse.</summary>
        </member>
        <member name="P:DotLogix.Core.Tracking.Snapshots.PropertyChangedSnapshot.OldValues">
            <inheritdoc />
        </member>
        <member name="P:DotLogix.Core.Tracking.Snapshots.PropertyChangedSnapshot.CurrentValues">
            <inheritdoc />
        </member>
        <member name="P:DotLogix.Core.Tracking.Snapshots.PropertyChangedSnapshot.ChangedValues">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Tracking.Snapshots.PropertyChangedSnapshot.DetectChanges">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Tracking.Snapshots.PropertyChangedSnapshot.AcceptChanges">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Tracking.Snapshots.PropertyChangedSnapshot.RevertChanges">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Tracking.Snapshots.Snapshotter">
            <summary>
            A static class to create snapshots
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.Snapshots.Snapshotter.CreateSnapshot(System.Object,DotLogix.Core.Reflection.Dynamics.AccessorTypes)">
            <summary>
            Create a snapshot
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.Snapshots.Snapshotter.CreateSnapshot(System.Object,System.Collections.Generic.IEnumerable{DotLogix.Core.Reflection.Dynamics.DynamicAccessor})">
            <summary>
            Create a snapshot
            </summary>
        </member>
        <member name="T:DotLogix.Core.Tracking.Snapshots.TrackedValue">
            <summary>
            A representation of a change tracked value accessor
            </summary>
        </member>
        <member name="P:DotLogix.Core.Tracking.Snapshots.TrackedValue.DynamicAccessor">
            <summary>
            The dynamic accessor
            </summary>
        </member>
        <member name="P:DotLogix.Core.Tracking.Snapshots.TrackedValue.Target">
            <summary>
            The object target
            </summary>
        </member>
        <member name="P:DotLogix.Core.Tracking.Snapshots.TrackedValue.Name">
            <summary>
            The name
            </summary>
        </member>
        <member name="P:DotLogix.Core.Tracking.Snapshots.TrackedValue.OldValue">
            <summary>
            The old value
            </summary>
        </member>
        <member name="P:DotLogix.Core.Tracking.Snapshots.TrackedValue.NewValue">
            <summary>
            The current value
            </summary>
        </member>
        <member name="P:DotLogix.Core.Tracking.Snapshots.TrackedValue.HasChanged">
            <summary>
            Check if the value has changed
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.Snapshots.TrackedValue.#ctor(System.Object,DotLogix.Core.Reflection.Dynamics.DynamicAccessor)">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Tracking.Snapshots.TrackedValue"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.Snapshots.TrackedValue.AcceptChanges">
            <summary>
            Accept changes
            </summary>
        </member>
        <member name="M:DotLogix.Core.Tracking.Snapshots.TrackedValue.RevertChanges">
            <summary>
            Revert changes
            </summary>
        </member>
        <member name="T:DotLogix.Core.Types.DataType">
            <summary>
            A more advanced type information object
            </summary>
        </member>
        <member name="P:DotLogix.Core.Types.DataType.EmptyType">
            <summary>
            The static empty type
            </summary>
        </member>
        <member name="P:DotLogix.Core.Types.DataType.Flags">
            <summary>
            Flags of the data type
            </summary>
        </member>
        <member name="P:DotLogix.Core.Types.DataType.Type">
            <summary>
            The type
            </summary>
        </member>
        <member name="P:DotLogix.Core.Types.DataType.UnderlayingType">
            <summary>
            The underlying type (enums)
            </summary>
        </member>
        <member name="P:DotLogix.Core.Types.DataType.ElementType">
            <summary>
            The element type (collections)
            </summary>
        </member>
        <member name="P:DotLogix.Core.Types.DataType.UnderlayingDataType">
            <summary>
            The underlying data type (enums)
            </summary>
        </member>
        <member name="P:DotLogix.Core.Types.DataType.ElementDataType">
            <summary>
            The element data type (collections)
            </summary>
        </member>
        <member name="M:DotLogix.Core.Types.DataType.#ctor(DotLogix.Core.Types.DataTypeFlags,System.Type,System.Type,System.Type)">
            <summary>
            Create a new instance of <see cref="T:DotLogix.Core.Types.DataType"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Types.DataType.Equals(DotLogix.Core.Types.DataType)">
            <summary>
            Check if the type equals another
            </summary>
        </member>
        <member name="M:DotLogix.Core.Types.DataType.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Types.DataType.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Types.DataTypeConverter">
            <summary>
            A singleton DataTypeConverter
            </summary>
        </member>
        <member name="P:DotLogix.Core.Types.DataTypeConverter.Instance">
            <summary>
            The static singleton instance
            </summary>
        </member>
        <member name="M:DotLogix.Core.Types.DataTypeConverter.GetDataType(System.Object)">
            <summary>
            Get a data type of a new instance
            </summary>
        </member>
        <member name="M:DotLogix.Core.Types.DataTypeConverter.GetDataType(System.Type)">
            <summary>
            Get a data type of a type
            </summary>
        </member>
        <member name="T:DotLogix.Core.Types.DataTypeFlags">
            <summary>
            Data type flags
            </summary>
        </member>
        <member name="F:DotLogix.Core.Types.DataTypeFlags.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:DotLogix.Core.Types.DataTypeFlags.Nullable">
            <summary>
            Nullable
            </summary>
        </member>
        <member name="F:DotLogix.Core.Types.DataTypeFlags.Primitive">
            <summary>
            Primitive value
            </summary>
        </member>
        <member name="F:DotLogix.Core.Types.DataTypeFlags.Complex">
            <summary>
            Complex value
            </summary>
        </member>
        <member name="F:DotLogix.Core.Types.DataTypeFlags.Collection">
            <summary>
            Collection type
            </summary>
        </member>
        <member name="F:DotLogix.Core.Types.DataTypeFlags.Guid">
            <summary>
            Guid
            </summary>
        </member>
        <member name="F:DotLogix.Core.Types.DataTypeFlags.Bool">
            <summary>
            Bool
            </summary>
        </member>
        <member name="F:DotLogix.Core.Types.DataTypeFlags.Char">
            <summary>
            Char
            </summary>
        </member>
        <member name="F:DotLogix.Core.Types.DataTypeFlags.Enum">
            <summary>
            Enum
            </summary>
        </member>
        <member name="F:DotLogix.Core.Types.DataTypeFlags.SByte">
            <summary>
            SByte
            </summary>
        </member>
        <member name="F:DotLogix.Core.Types.DataTypeFlags.Byte">
            <summary>
            Byte
            </summary>
        </member>
        <member name="F:DotLogix.Core.Types.DataTypeFlags.Short">
            <summary>
            Short
            </summary>
        </member>
        <member name="F:DotLogix.Core.Types.DataTypeFlags.UShort">
            <summary>
            UShort
            </summary>
        </member>
        <member name="F:DotLogix.Core.Types.DataTypeFlags.Int">
            <summary>
            Int
            </summary>
        </member>
        <member name="F:DotLogix.Core.Types.DataTypeFlags.UInt">
            <summary>
            UInt
            </summary>
        </member>
        <member name="F:DotLogix.Core.Types.DataTypeFlags.Long">
            <summary>
            Long
            </summary>
        </member>
        <member name="F:DotLogix.Core.Types.DataTypeFlags.ULong">
            <summary>
            ULong
            </summary>
        </member>
        <member name="F:DotLogix.Core.Types.DataTypeFlags.Float">
            <summary>
            Float
            </summary>
        </member>
        <member name="F:DotLogix.Core.Types.DataTypeFlags.Double">
            <summary>
            Double
            </summary>
        </member>
        <member name="F:DotLogix.Core.Types.DataTypeFlags.Decimal">
            <summary>
            Decimal
            </summary>
        </member>
        <member name="F:DotLogix.Core.Types.DataTypeFlags.DateTime">
            <summary>
            DateTime
            </summary>
        </member>
        <member name="F:DotLogix.Core.Types.DataTypeFlags.DateTimeOffset">
            <summary>
            DateTimeOffset
            </summary>
        </member>
        <member name="F:DotLogix.Core.Types.DataTypeFlags.TimeSpan">
            <summary>
            TimeSpan
            </summary>
        </member>
        <member name="F:DotLogix.Core.Types.DataTypeFlags.String">
            <summary>
            String
            </summary>
        </member>
        <member name="F:DotLogix.Core.Types.DataTypeFlags.Object">
            <summary>
            Object
            </summary>
        </member>
        <member name="F:DotLogix.Core.Types.DataTypeFlags.NumericMask">
            <summary>
            NumericMask
            </summary>
        </member>
        <member name="F:DotLogix.Core.Types.DataTypeFlags.PrimitiveMask">
            <summary>
            PrimitiveMask
            </summary>
        </member>
        <member name="F:DotLogix.Core.Types.DataTypeFlags.TimeMask">
            <summary>
            TimeMask
            </summary>
        </member>
        <member name="F:DotLogix.Core.Types.DataTypeFlags.TextMask">
            <summary>
            TextMask
            </summary>
        </member>
        <member name="F:DotLogix.Core.Types.DataTypeFlags.CategoryMask">
            <summary>
            CategoryMask
            </summary>
        </member>
        <member name="T:DotLogix.Core.Utils.DiffEnumerable`1">
            <summary>
            A class to diff two enumerable
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:DotLogix.Core.Utils.DiffEnumerable`1.LeftOnly">
            <summary>
            Values only occuring left
            </summary>
        </member>
        <member name="P:DotLogix.Core.Utils.DiffEnumerable`1.Intersect">
            <summary>
            Values occuring in both
            </summary>
        </member>
        <member name="P:DotLogix.Core.Utils.DiffEnumerable`1.RightOnly">
            <summary>
            Values only occuring right
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.DiffEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Utils.DiffEnumerable`1"/>
            </summary>
        </member>
        <member name="T:DotLogix.Core.Utils.DiffEnumerable`2">
            <summary>
            A class to diff two enumerable
            </summary>
        </member>
        <member name="P:DotLogix.Core.Utils.DiffEnumerable`2.LeftOnly">
            <summary>
            Values only occuring left
            </summary>
        </member>
        <member name="P:DotLogix.Core.Utils.DiffEnumerable`2.Intersect">
            <summary>
            Values occuring in both
            </summary>
        </member>
        <member name="P:DotLogix.Core.Utils.DiffEnumerable`2.RightOnly">
            <summary>
            Values only occuring right
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.DiffEnumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{DotLogix.Core.Utils.DiffEnumerable{`0,`1}.DiffValue},System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Utils.DiffEnumerable`2"/>
            </summary>
        </member>
        <member name="T:DotLogix.Core.Utils.DiffEnumerable`2.DiffValue">
            <summary>
            A tuple containing the left and right values of a diff
            </summary>
        </member>
        <member name="P:DotLogix.Core.Utils.DiffEnumerable`2.DiffValue.Left">
            <summary>
            Left
            </summary>
        </member>
        <member name="P:DotLogix.Core.Utils.DiffEnumerable`2.DiffValue.Right">
            <summary>
            Right
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.DiffEnumerable`2.DiffValue.#ctor(`0,`1)">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Utils.DiffEnumerable`2.DiffValue"/>
            </summary>
        </member>
        <member name="T:DotLogix.Core.Utils.IInstantiator">
            <summary>
            An interface to instantiate types
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.IInstantiator.GetInstance">
            <summary>
            Get or create a new instance
            </summary>
        </member>
        <member name="T:DotLogix.Core.Utils.IArgsInstantiator">
            <summary>
            An interface to instantiate types with arguments
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.IArgsInstantiator.GetInstance(System.Object[])">
            <summary>
            Get or create a new instance
            </summary>
        </member>
        <member name="T:DotLogix.Core.Utils.Instantiator">
            <summary>
            A static class to create instantiators
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Instantiator.UseSingletonProperty(System.Type,System.String,System.Type)">
            <summary>
            Create an instantiator with a singleton property
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Instantiator.UseDefaultCtor(System.Type,System.Type)">
            <summary>
            Create an instantiator using the default constructor
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Instantiator.UseDelegate(System.Func{System.Object})">
            <summary>
            Create an instantiator using a delegate
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Instantiator.UseDelegate(System.Func{System.Object[],System.Object})">
            <summary>
            Create an instantiator using a delegate
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Instantiator.UseCtor(System.Type,System.Type[],System.Type)">
            <summary>
            Create an instantiator using a constructor
            </summary>
        </member>
        <member name="T:DotLogix.Core.Utils.Instantiators.DelegateArgsInstantiator">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Utils.Instantiators.DelegateArgsInstantiator.#ctor(System.Func{System.Object[],System.Object})">
            <summary>
            Create a new instance of <see cref="T:DotLogix.Core.Utils.Instantiators.DelegateArgsInstantiator"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Instantiators.DelegateArgsInstantiator.GetInstance(System.Object[])">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Utils.Instantiators.DelegateInstantiator">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Utils.Instantiators.DelegateInstantiator.#ctor(System.Func{System.Object})">
            <summary>
            Create a new instance of <see cref="T:DotLogix.Core.Utils.Instantiators.DelegateInstantiator"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Instantiators.DelegateInstantiator.GetInstance">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Utils.Instantiators.DynamicArgsInstantiator">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Utils.Instantiators.DynamicArgsInstantiator.#ctor(DotLogix.Core.Reflection.Dynamics.DynamicCtor)">
            <summary>
            Create a new instance of <see cref="T:DotLogix.Core.Utils.Instantiators.DynamicArgsInstantiator"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Instantiators.DynamicArgsInstantiator.GetInstance(System.Object[])">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Utils.Instantiators.DynamicInstantiator">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Utils.Instantiators.DynamicInstantiator.#ctor(DotLogix.Core.Reflection.Dynamics.DynamicCtor)">
            <summary>
            Create a new instance of <see cref="T:DotLogix.Core.Utils.Instantiators.DynamicInstantiator"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Instantiators.DynamicInstantiator.GetInstance">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Utils.Instantiators.SingletonInstantiator">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Utils.Instantiators.SingletonInstantiator.#ctor(DotLogix.Core.Reflection.Dynamics.DynamicProperty)">
            <summary>
            Create a new instance of <see cref="T:DotLogix.Core.Utils.Instantiators.SingletonInstantiator"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Instantiators.SingletonInstantiator.GetInstance">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Utils.LazyMember`1">
            <summary>
            A property created on the fly
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="P:DotLogix.Core.Utils.LazyMember`1.HasValue">
            <summary>
            Checks if the value has been created already
            </summary>
        </member>
        <member name="P:DotLogix.Core.Utils.LazyMember`1.Value">
            <summary>
            Get or create a value
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.LazyMember`1.#ctor(System.Func{`0})">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Utils.LazyMember`1"/>
            </summary>
            <param name="valueInitializer"></param>
        </member>
        <member name="M:DotLogix.Core.Utils.LazyMember`1.EnsureValue">
            <summary>
            Get or create the value manually
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.LazyMember`1.op_Implicit(System.Func{`0})~DotLogix.Core.Utils.LazyMember{`0}">
            <summary>
            Create a new instance of <see cref="T:DotLogix.Core.Utils.LazyMember`1"/> using an initializer function
            </summary>
            <param name="valueInitializer"></param>
        </member>
        <member name="T:DotLogix.Core.Utils.Mappers.DynamicValueGetter`2">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Utils.Mappers.DynamicValueGetter`2.#ctor(DotLogix.Core.Reflection.Dynamics.DynamicAccessor)">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Utils.Mappers.DynamicValueSetter`2">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Utils.Mappers.DynamicValueSetter`2.#ctor(DotLogix.Core.Reflection.Dynamics.DynamicAccessor)">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Utils.Mappers.IMapper`2">
            <summary>
            An interface representation type mappers
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Mappers.IMapper`2.Map(`0,`1)">
            <summary>
            Maps a source type to a target type
            </summary>
        </member>
        <member name="T:DotLogix.Core.Utils.Mappers.IValueGetter`2">
            <summary>
            An interface representation value resolvers
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Mappers.IValueGetter`2.AddPreCondition(System.Func{`0,System.Boolean})">
            <summary>
            Add a pre-conditions executed before a value will be resolved
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Mappers.IValueGetter`2.AddPostCondition(System.Func{`0,`1,System.Boolean})">
            <summary>
            Add a post-conditions executed after a value has been resolved
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Mappers.IValueGetter`2.TryGet(`0,`1@)">
            <summary>
            Tries to resolve a value
            </summary>
        </member>
        <member name="T:DotLogix.Core.Utils.Mappers.IValueSetter`2">
            <summary>
            An interface representation value setters
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Mappers.IValueSetter`2.AddPreCondition(System.Func{`0,System.Boolean})">
            <summary>
            Add a pre-conditions executed before a value will be set
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Mappers.IValueSetter`2.AddPreCondition(System.Func{`0,`1,System.Boolean})">
            <summary>
            Add a pre-conditions executed before a value will be set
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Mappers.IValueSetter`2.TrySet(`0,`1)">
            <summary>
            Tries to set a value
            </summary>
        </member>
        <member name="T:DotLogix.Core.Utils.Mappers.Mappers">
            <summary>
            A static class class helping to create type to type mappers
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Mappers.Mappers.Map``2(System.Action{DotLogix.Core.Utils.Mappers.MapBuilder{``0,``1}})">
            <summary>
            Creates a mapper based on a configuration function
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Mappers.Mappers.AutoMap``2(System.Action{DotLogix.Core.Utils.Mappers.MapBuilder{``0,``1}})">
            <summary>
            Creates a mapper based on a configuration function auto-maps all supported properties (s.[name] => t.[name])
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Mappers.Mappers.Map(System.Type,System.Type,System.Action{DotLogix.Core.Utils.Mappers.MapBuilder{System.Object,System.Object}})">
            <summary>
            Creates a mapper based on a configuration function
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Mappers.Mappers.AutoMap(System.Type,System.Type,System.Action{DotLogix.Core.Utils.Mappers.MapBuilder{System.Object,System.Object}})">
            <summary>
            Creates a mapper based on a configuration function auto-maps all supported properties (s.[name] => t.[name])
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Mappers.ValueAutoConvertingMapper`4.#ctor(DotLogix.Core.Utils.Mappers.IValueGetter{`0,`1},DotLogix.Core.Utils.Mappers.IValueSetter{`2,`3})">
            <summary>
                Initialisiert eine neue Instanz der <see cref="T:System.Object" />-Klasse.
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Mappers.ValueConvertingMapper`4.#ctor(DotLogix.Core.Utils.Mappers.IValueGetter{`0,`1},DotLogix.Core.Utils.Mappers.IValueSetter{`2,`3},System.Func{`1,`3})">
            <summary>
                Initialisiert eine neue Instanz der <see cref="T:System.Object" />-Klasse.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:DotLogix.Core.Utils.Mappers.ValueGetterBase`2" -->
        <member name="P:DotLogix.Core.Utils.Mappers.ValueGetterBase`2.PreConditionFuncs">
            <summary>
            A list of pre-conditions executed before a value will be resolved
            </summary>
        </member>
        <member name="P:DotLogix.Core.Utils.Mappers.ValueGetterBase`2.PostConditionFuncs">
            <summary>
            A list of post-conditions executed after a value has been resolved
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Mappers.ValueGetterBase`2.AddPreCondition(System.Func{`0,System.Boolean})">
            <summary>
            Add a pre-conditions executed before a value will be resolved
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Mappers.ValueGetterBase`2.AddPostCondition(System.Func{`0,`1,System.Boolean})">
            <summary>
            Add a post-conditions executed after a value has been resolved
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Mappers.ValueGetterBase`2.TryGet(`0,`1@)">
            <summary>
            Tries to resolve a value
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Mappers.ValueGetterBase`2.TryGetValue(`0,`1@)">
            <summary>
            Tries to resolve a value
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Mappers.ValueGetterBase`2.CheckPreConditions(`0)">
            <summary>
            Check if all pre-conditions are fulfilled
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Mappers.ValueGetterBase`2.CheckPostConditions(`0,`1)">
            <summary>
            Check if all post-conditions are fulfilled
            </summary>
        </member>
        <member name="T:DotLogix.Core.Utils.Patterns.IRegexPatternType">
            <summary>
            A pattern type to match regex expressions
            </summary>
        </member>
        <member name="P:DotLogix.Core.Utils.Patterns.IRegexPatternType.Name">
            <summary>
            The name
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Patterns.IRegexPatternType.TryGetRegexPattern(System.String,System.String[],System.String@)">
            <summary>
            Tries to convert the arguments to a valid regex expression
            </summary>
            <param name="variant"></param>
            <param name="args"></param>
            <param name="pattern"></param>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.Utils.Patterns.PatternParser">
            <summary>
            A parser for patterns
            </summary>
        </member>
        <member name="P:DotLogix.Core.Utils.Patterns.PatternParser.Patterns">
            <summary>
            Patterns
            </summary>
        </member>
        <member name="P:DotLogix.Core.Utils.Patterns.PatternParser.Default">
            <summary>
            The default pattern parser
            </summary>
        </member>
        <member name="P:DotLogix.Core.Utils.Patterns.PatternParser.Item(System.String)">
            <summary>
            Get a regex pattern type by name
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Patterns.PatternParser.GetPattern(System.String)">
            <summary>
            Get a regex pattern type by name
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Patterns.PatternParser.TryGetPattern(System.String,DotLogix.Core.Utils.Patterns.IRegexPatternType@)">
            <summary>
            Try get a regex pattern type by name
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Patterns.PatternParser.ContainsPattern(System.String)">
            <summary>
            Check if a regex pattern already exists
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Patterns.PatternParser.AddPattern(DotLogix.Core.Utils.Patterns.IRegexPatternType)">
            <summary>
            Add a regex pattern
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Patterns.PatternParser.RemovePattern(System.String)">
            <summary>
            Remove a regex pattern
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Patterns.PatternParser.ToRegexPattern(System.String)">
            <summary>
            Convert a pattern to a regex expression
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Patterns.PatternParser.Clone">
            <summary>
            Clone the pattern parser
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Utils.Patterns.PatternParser.System#ICloneable#Clone">
            <summary>Creates a new object that is a copy of the current instance.</summary>
            <returns>A new object that is a copy of this instance.</returns>
        </member>
        <member name="T:DotLogix.Core.Utils.Patterns.Range">
            <summary>
            A Range
            </summary>
        </member>
        <member name="F:DotLogix.Core.Utils.Patterns.Range.Min">
            <summary>
            The min value
            </summary>
        </member>
        <member name="F:DotLogix.Core.Utils.Patterns.Range.Max">
            <summary>
            Tha max value
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Patterns.Range.#ctor(System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Creates a new <see cref="T:DotLogix.Core.Utils.Patterns.Range"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Patterns.Range.ToRegexRange(System.String)">
            <summary>
            Creates a regex range statement
            </summary>
            <param name="onAny"></param>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Utils.Patterns.Range.ToString">
            <summary>
            Creates a parseable representation of the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotLogix.Core.Utils.Patterns.Range.Parse(System.String)">
            <summary>
            Parse
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Patterns.Range.TryParse(System.String,DotLogix.Core.Utils.Patterns.Range@)">
            <summary>
            Try to parse a range
            </summary>
            <param name="value"></param>
            <param name="range"></param>
            <returns></returns>
        </member>
        <member name="T:DotLogix.Core.Utils.Patterns.RegexPatternType">
            <inheritdoc />
        </member>
        <member name="P:DotLogix.Core.Utils.Patterns.RegexPatternType.DefaultVariant">
            <summary>
            The default regex variant
            </summary>
        </member>
        <member name="P:DotLogix.Core.Utils.Patterns.RegexPatternType.PatternVariants">
            <summary>
            The pattern variants
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Patterns.RegexPatternType.#ctor(System.String,System.String,System.Collections.Generic.IReadOnlyDictionary{System.String,System.String})">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Utils.Patterns.RegexPatternType"/>
            </summary>
            <param name="name">The type name</param>
            <param name="defaultVariant">The default variant</param>
            <param name="patternVariants">The available variants</param>
        </member>
        <member name="M:DotLogix.Core.Utils.Patterns.RegexPatternType.#ctor(System.String,System.String)">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Utils.Patterns.RegexPatternType"/>
            </summary>
            <param name="name">The type name</param>
            <param name="pattern">The regex pattern</param>
        </member>
        <member name="P:DotLogix.Core.Utils.Patterns.RegexPatternType.Name">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Utils.Patterns.RegexPatternType.TryGetRegexPattern(System.String,System.String[],System.String@)">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Utils.Patterns.RepeatedRegexPatternType">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Utils.Patterns.RepeatedRegexPatternType.#ctor(System.String,System.String,System.Collections.Generic.IReadOnlyDictionary{System.String,System.String})">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Utils.Patterns.RepeatedRegexPatternType"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Patterns.RepeatedRegexPatternType.#ctor(System.String,System.String)">
            <summary>
            Creates a new instance of <see cref="T:DotLogix.Core.Utils.Patterns.RepeatedRegexPatternType"/>
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Patterns.RepeatedRegexPatternType.TryGetRegexPattern(System.String,System.String[],System.String@)">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Utils.Replicator">
            <summary>
            A singleton instance of <see cref="T:DotLogix.Core.Utils.Replicator"/>
            </summary>
        </member>
        <member name="P:DotLogix.Core.Utils.Replicator.Instance">
            <summary>
            The singleton instance
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Replicator.FlatClone``1(``0)">
            <summary>
            Create a shallow copy of an object
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Replicator.FlatClone(System.Object)">
            <summary>
            Create a shallow copy of an object
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.Replicator.FlatClone(System.Type,System.Object,System.Object)">
            <summary>
            Create a shallow copy of an object
            </summary>
        </member>
        <member name="T:DotLogix.Core.Utils.SelectorComparer`2">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Utils.SelectorComparer`2.#ctor(System.Func{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Utils.SelectorComparer`2.Compare(`0,`0)">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Utils.SelectorEqualityComparer`2">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Utils.SelectorEqualityComparer`2.#ctor(System.Func{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Utils.SelectorEqualityComparer`2.Equals(`0,`0)">
            <inheritdoc />
        </member>
        <member name="M:DotLogix.Core.Utils.SelectorEqualityComparer`2.GetHashCode(`0)">
            <inheritdoc />
        </member>
        <member name="T:DotLogix.Core.Utils.StreamSegment">
            <summary>
            A segment of a stream
            </summary>
        </member>
        <member name="P:DotLogix.Core.Utils.StreamSegment.Stream">
            <summary>
            The underlying stream
            </summary>
        </member>
        <member name="P:DotLogix.Core.Utils.StreamSegment.Offset">
            <summary>
            The offset to the start of the stream
            </summary>
        </member>
        <member name="M:DotLogix.Core.Utils.StreamSegment.#ctor(System.IO.Stream,System.Int64,System.Int64)">
            <summary>Initializes a new instance of the <see cref="T:System.Object"></see> class.</summary>
        </member>
        <member name="M:DotLogix.Core.Utils.StreamSegment.Flush">
            <summary>When overridden in a derived class, clears all buffers for this stream and causes any buffered data to be written to the underlying device.</summary>
            <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
        </member>
        <member name="M:DotLogix.Core.Utils.StreamSegment.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>When overridden in a derived class, reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.</summary>
            <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between offset and (offset + count - 1) replaced by the bytes read from the current source.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin storing the data read from the current stream.</param>
            <param name="count">The maximum number of bytes to be read from the current stream.</param>
            <returns>The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</returns>
            <exception cref="T:System.ArgumentException">The sum of <paramref name="offset">offset</paramref> and <paramref name="count">count</paramref> is larger than the buffer length.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="buffer">buffer</paramref> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset">offset</paramref> or <paramref name="count">count</paramref> is negative.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
            <exception cref="T:System.NotSupportedException">The stream does not support reading.</exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed.</exception>
        </member>
        <member name="M:DotLogix.Core.Utils.StreamSegment.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>When overridden in a derived class, sets the position within the current stream.</summary>
            <param name="offset">A byte offset relative to the origin parameter.</param>
            <param name="origin">A value of type <see cref="T:System.IO.SeekOrigin"></see> indicating the reference point used to obtain the new position.</param>
            <returns>The new position within the current stream.</returns>
            <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
            <exception cref="T:System.NotSupportedException">The stream does not support seeking, such as if the stream is constructed from a pipe or console output.</exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed.</exception>
        </member>
        <member name="M:DotLogix.Core.Utils.StreamSegment.SetLength(System.Int64)">
            <summary>When overridden in a derived class, sets the length of the current stream.</summary>
            <param name="value">The desired length of the current stream in bytes.</param>
            <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
            <exception cref="T:System.NotSupportedException">The stream does not support both writing and seeking, such as if the stream is constructed from a pipe or console output.</exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed.</exception>
        </member>
        <member name="M:DotLogix.Core.Utils.StreamSegment.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>When overridden in a derived class, writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.</summary>
            <param name="buffer">An array of bytes. This method copies count bytes from buffer to the current stream.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin copying bytes to the current stream.</param>
            <param name="count">The number of bytes to be written to the current stream.</param>
            <exception cref="T:System.ArgumentException">The sum of <paramref name="offset">offset</paramref> and <paramref name="count">count</paramref> is greater than the buffer length.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="buffer">buffer</paramref> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset">offset</paramref> or <paramref name="count">count</paramref> is negative.</exception>
            <exception cref="T:System.IO.IOException">An I/O error occured, such as the specified file cannot be found.</exception>
            <exception cref="T:System.NotSupportedException">The stream does not support writing.</exception>
            <exception cref="T:System.ObjectDisposedException"><see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)"></see> was called after the stream was closed.</exception>
        </member>
        <member name="P:DotLogix.Core.Utils.StreamSegment.CanRead">
            <summary>When overridden in a derived class, gets a value indicating whether the current stream supports reading.</summary>
            <returns>true if the stream supports reading; otherwise, false.</returns>
        </member>
        <member name="P:DotLogix.Core.Utils.StreamSegment.CanSeek">
            <summary>When overridden in a derived class, gets a value indicating whether the current stream supports seeking.</summary>
            <returns>true if the stream supports seeking; otherwise, false.</returns>
        </member>
        <member name="P:DotLogix.Core.Utils.StreamSegment.CanWrite">
            <summary>When overridden in a derived class, gets a value indicating whether the current stream supports writing.</summary>
            <returns>true if the stream supports writing; otherwise, false.</returns>
        </member>
        <member name="P:DotLogix.Core.Utils.StreamSegment.Length">
            <summary>When overridden in a derived class, gets the length in bytes of the stream.</summary>
            <returns>A long value representing the length of the stream in bytes.</returns>
            <exception cref="T:System.NotSupportedException">A class derived from Stream does not support seeking.</exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed.</exception>
        </member>
        <member name="P:DotLogix.Core.Utils.StreamSegment.Position">
            <summary>When overridden in a derived class, gets or sets the position within the current stream.</summary>
            <returns>The current position within the stream.</returns>
            <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
            <exception cref="T:System.NotSupportedException">The stream does not support seeking.</exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed.</exception>
        </member>
        <member name="M:DotLogix.Core.Utils.StreamSegment.Dispose(System.Boolean)">
            <summary>Releases the unmanaged resources used by the <see cref="T:System.IO.Stream"></see> and optionally releases the managed resources.</summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
    </members>
</doc>
