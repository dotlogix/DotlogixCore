

using System.Diagnostics.CodeAnalysis;
using System.Linq.Expressions;

namespace DotLogix.Core.Expressions {
    [SuppressMessage("ReSharper", "RedundantTypeArgumentsOfMethod")]
    public static partial class Lambdas {
        public static Lambda<int> Add(this Lambda<sbyte> instance, Lambda<sbyte> other) {
            return Expression.Add(instance, other);
        }

        public static Lambda<int> Add(this Lambda<byte> instance, Lambda<byte> other) {
            return Expression.Add(instance, other);
        }

        public static Lambda<int> Add(this Lambda<short> instance, Lambda<short> other) {
            return Expression.Add(instance, other);
        }

        public static Lambda<int> Add(this Lambda<ushort> instance, Lambda<ushort> other) {
            return Expression.Add(instance, other);
        }

        public static Lambda<int> Add(this Lambda<int> instance, Lambda<int> other) {
            return Expression.Add(instance, other);
        }

        public static Lambda<uint> Add(this Lambda<uint> instance, Lambda<uint> other) {
            return Expression.Add(instance, other);
        }

        public static Lambda<long> Add(this Lambda<long> instance, Lambda<long> other) {
            return Expression.Add(instance, other);
        }

        public static Lambda<ulong> Add(this Lambda<ulong> instance, Lambda<ulong> other) {
            return Expression.Add(instance, other);
        }

        public static Lambda<float> Add(this Lambda<float> instance, Lambda<float> other) {
            return Expression.Add(instance, other);
        }

        public static Lambda<double> Add(this Lambda<double> instance, Lambda<double> other) {
            return Expression.Add(instance, other);
        }

        public static Lambda<int> Subtract(this Lambda<sbyte> instance, Lambda<sbyte> other) {
            return Expression.Subtract(instance, other);
        }

        public static Lambda<int> Subtract(this Lambda<byte> instance, Lambda<byte> other) {
            return Expression.Subtract(instance, other);
        }

        public static Lambda<int> Subtract(this Lambda<short> instance, Lambda<short> other) {
            return Expression.Subtract(instance, other);
        }

        public static Lambda<int> Subtract(this Lambda<ushort> instance, Lambda<ushort> other) {
            return Expression.Subtract(instance, other);
        }

        public static Lambda<int> Subtract(this Lambda<int> instance, Lambda<int> other) {
            return Expression.Subtract(instance, other);
        }

        public static Lambda<uint> Subtract(this Lambda<uint> instance, Lambda<uint> other) {
            return Expression.Subtract(instance, other);
        }

        public static Lambda<long> Subtract(this Lambda<long> instance, Lambda<long> other) {
            return Expression.Subtract(instance, other);
        }

        public static Lambda<ulong> Subtract(this Lambda<ulong> instance, Lambda<ulong> other) {
            return Expression.Subtract(instance, other);
        }

        public static Lambda<float> Subtract(this Lambda<float> instance, Lambda<float> other) {
            return Expression.Subtract(instance, other);
        }

        public static Lambda<double> Subtract(this Lambda<double> instance, Lambda<double> other) {
            return Expression.Subtract(instance, other);
        }

        public static Lambda<int> Divide(this Lambda<sbyte> instance, Lambda<sbyte> other) {
            return Expression.Divide(instance, other);
        }

        public static Lambda<int> Divide(this Lambda<byte> instance, Lambda<byte> other) {
            return Expression.Divide(instance, other);
        }

        public static Lambda<int> Divide(this Lambda<short> instance, Lambda<short> other) {
            return Expression.Divide(instance, other);
        }

        public static Lambda<int> Divide(this Lambda<ushort> instance, Lambda<ushort> other) {
            return Expression.Divide(instance, other);
        }

        public static Lambda<int> Divide(this Lambda<int> instance, Lambda<int> other) {
            return Expression.Divide(instance, other);
        }

        public static Lambda<uint> Divide(this Lambda<uint> instance, Lambda<uint> other) {
            return Expression.Divide(instance, other);
        }

        public static Lambda<long> Divide(this Lambda<long> instance, Lambda<long> other) {
            return Expression.Divide(instance, other);
        }

        public static Lambda<ulong> Divide(this Lambda<ulong> instance, Lambda<ulong> other) {
            return Expression.Divide(instance, other);
        }

        public static Lambda<float> Divide(this Lambda<float> instance, Lambda<float> other) {
            return Expression.Divide(instance, other);
        }

        public static Lambda<double> Divide(this Lambda<double> instance, Lambda<double> other) {
            return Expression.Divide(instance, other);
        }

        public static Lambda<int> Multiply(this Lambda<sbyte> instance, Lambda<sbyte> other) {
            return Expression.Multiply(instance, other);
        }

        public static Lambda<int> Multiply(this Lambda<byte> instance, Lambda<byte> other) {
            return Expression.Multiply(instance, other);
        }

        public static Lambda<int> Multiply(this Lambda<short> instance, Lambda<short> other) {
            return Expression.Multiply(instance, other);
        }

        public static Lambda<int> Multiply(this Lambda<ushort> instance, Lambda<ushort> other) {
            return Expression.Multiply(instance, other);
        }

        public static Lambda<int> Multiply(this Lambda<int> instance, Lambda<int> other) {
            return Expression.Multiply(instance, other);
        }

        public static Lambda<uint> Multiply(this Lambda<uint> instance, Lambda<uint> other) {
            return Expression.Multiply(instance, other);
        }

        public static Lambda<long> Multiply(this Lambda<long> instance, Lambda<long> other) {
            return Expression.Multiply(instance, other);
        }

        public static Lambda<ulong> Multiply(this Lambda<ulong> instance, Lambda<ulong> other) {
            return Expression.Multiply(instance, other);
        }

        public static Lambda<float> Multiply(this Lambda<float> instance, Lambda<float> other) {
            return Expression.Multiply(instance, other);
        }

        public static Lambda<double> Multiply(this Lambda<double> instance, Lambda<double> other) {
            return Expression.Multiply(instance, other);
        }

        public static Lambda<int> Modulo(this Lambda<sbyte> instance, Lambda<sbyte> other) {
            return Expression.Modulo(instance, other);
        }

        public static Lambda<int> Modulo(this Lambda<byte> instance, Lambda<byte> other) {
            return Expression.Modulo(instance, other);
        }

        public static Lambda<int> Modulo(this Lambda<short> instance, Lambda<short> other) {
            return Expression.Modulo(instance, other);
        }

        public static Lambda<int> Modulo(this Lambda<ushort> instance, Lambda<ushort> other) {
            return Expression.Modulo(instance, other);
        }

        public static Lambda<int> Modulo(this Lambda<int> instance, Lambda<int> other) {
            return Expression.Modulo(instance, other);
        }

        public static Lambda<uint> Modulo(this Lambda<uint> instance, Lambda<uint> other) {
            return Expression.Modulo(instance, other);
        }

        public static Lambda<long> Modulo(this Lambda<long> instance, Lambda<long> other) {
            return Expression.Modulo(instance, other);
        }

        public static Lambda<ulong> Modulo(this Lambda<ulong> instance, Lambda<ulong> other) {
            return Expression.Modulo(instance, other);
        }

        public static Lambda<float> Modulo(this Lambda<float> instance, Lambda<float> other) {
            return Expression.Modulo(instance, other);
        }

        public static Lambda<double> Modulo(this Lambda<double> instance, Lambda<double> other) {
            return Expression.Modulo(instance, other);
        }

        public static Lambda<int> Power(this Lambda<sbyte> instance, Lambda<sbyte> other) {
            return Expression.Power(instance, other);
        }

        public static Lambda<int> Power(this Lambda<byte> instance, Lambda<byte> other) {
            return Expression.Power(instance, other);
        }

        public static Lambda<int> Power(this Lambda<short> instance, Lambda<short> other) {
            return Expression.Power(instance, other);
        }

        public static Lambda<int> Power(this Lambda<ushort> instance, Lambda<ushort> other) {
            return Expression.Power(instance, other);
        }

        public static Lambda<int> Power(this Lambda<int> instance, Lambda<int> other) {
            return Expression.Power(instance, other);
        }

        public static Lambda<uint> Power(this Lambda<uint> instance, Lambda<uint> other) {
            return Expression.Power(instance, other);
        }

        public static Lambda<long> Power(this Lambda<long> instance, Lambda<long> other) {
            return Expression.Power(instance, other);
        }

        public static Lambda<ulong> Power(this Lambda<ulong> instance, Lambda<ulong> other) {
            return Expression.Power(instance, other);
        }

        public static Lambda<float> Power(this Lambda<float> instance, Lambda<float> other) {
            return Expression.Power(instance, other);
        }

        public static Lambda<double> Power(this Lambda<double> instance, Lambda<double> other) {
            return Expression.Power(instance, other);
        }

        public static Lambda<int> And(this Lambda<sbyte> instance, Lambda<sbyte> other) {
            return Expression.And(instance, other);
        }

        public static Lambda<int> And(this Lambda<byte> instance, Lambda<byte> other) {
            return Expression.And(instance, other);
        }

        public static Lambda<int> And(this Lambda<short> instance, Lambda<short> other) {
            return Expression.And(instance, other);
        }

        public static Lambda<int> And(this Lambda<ushort> instance, Lambda<ushort> other) {
            return Expression.And(instance, other);
        }

        public static Lambda<int> And(this Lambda<int> instance, Lambda<int> other) {
            return Expression.And(instance, other);
        }

        public static Lambda<uint> And(this Lambda<uint> instance, Lambda<uint> other) {
            return Expression.And(instance, other);
        }

        public static Lambda<long> And(this Lambda<long> instance, Lambda<long> other) {
            return Expression.And(instance, other);
        }

        public static Lambda<ulong> And(this Lambda<ulong> instance, Lambda<ulong> other) {
            return Expression.And(instance, other);
        }

        public static Lambda<int> Or(this Lambda<sbyte> instance, Lambda<sbyte> other) {
            return Expression.Or(instance, other);
        }

        public static Lambda<int> Or(this Lambda<byte> instance, Lambda<byte> other) {
            return Expression.Or(instance, other);
        }

        public static Lambda<int> Or(this Lambda<short> instance, Lambda<short> other) {
            return Expression.Or(instance, other);
        }

        public static Lambda<int> Or(this Lambda<ushort> instance, Lambda<ushort> other) {
            return Expression.Or(instance, other);
        }

        public static Lambda<int> Or(this Lambda<int> instance, Lambda<int> other) {
            return Expression.Or(instance, other);
        }

        public static Lambda<uint> Or(this Lambda<uint> instance, Lambda<uint> other) {
            return Expression.Or(instance, other);
        }

        public static Lambda<long> Or(this Lambda<long> instance, Lambda<long> other) {
            return Expression.Or(instance, other);
        }

        public static Lambda<ulong> Or(this Lambda<ulong> instance, Lambda<ulong> other) {
            return Expression.Or(instance, other);
        }

        public static Lambda<int> ExclusiveOr(this Lambda<sbyte> instance, Lambda<sbyte> other) {
            return Expression.ExclusiveOr(instance, other);
        }

        public static Lambda<int> ExclusiveOr(this Lambda<byte> instance, Lambda<byte> other) {
            return Expression.ExclusiveOr(instance, other);
        }

        public static Lambda<int> ExclusiveOr(this Lambda<short> instance, Lambda<short> other) {
            return Expression.ExclusiveOr(instance, other);
        }

        public static Lambda<int> ExclusiveOr(this Lambda<ushort> instance, Lambda<ushort> other) {
            return Expression.ExclusiveOr(instance, other);
        }

        public static Lambda<int> ExclusiveOr(this Lambda<int> instance, Lambda<int> other) {
            return Expression.ExclusiveOr(instance, other);
        }

        public static Lambda<uint> ExclusiveOr(this Lambda<uint> instance, Lambda<uint> other) {
            return Expression.ExclusiveOr(instance, other);
        }

        public static Lambda<long> ExclusiveOr(this Lambda<long> instance, Lambda<long> other) {
            return Expression.ExclusiveOr(instance, other);
        }

        public static Lambda<ulong> ExclusiveOr(this Lambda<ulong> instance, Lambda<ulong> other) {
            return Expression.ExclusiveOr(instance, other);
        }

        public static Lambda<int> LeftShift(this Lambda<sbyte> instance, Lambda<int> other) {
            return Expression.LeftShift(instance, other);
        }

        public static Lambda<int> LeftShift(this Lambda<byte> instance, Lambda<int> other) {
            return Expression.LeftShift(instance, other);
        }

        public static Lambda<int> LeftShift(this Lambda<short> instance, Lambda<int> other) {
            return Expression.LeftShift(instance, other);
        }

        public static Lambda<int> LeftShift(this Lambda<ushort> instance, Lambda<int> other) {
            return Expression.LeftShift(instance, other);
        }

        public static Lambda<int> LeftShift(this Lambda<int> instance, Lambda<int> other) {
            return Expression.LeftShift(instance, other);
        }

        public static Lambda<uint> LeftShift(this Lambda<uint> instance, Lambda<int> other) {
            return Expression.LeftShift(instance, other);
        }

        public static Lambda<long> LeftShift(this Lambda<long> instance, Lambda<int> other) {
            return Expression.LeftShift(instance, other);
        }

        public static Lambda<ulong> LeftShift(this Lambda<ulong> instance, Lambda<int> other) {
            return Expression.LeftShift(instance, other);
        }

        public static Lambda<int> RightShift(this Lambda<sbyte> instance, Lambda<int> other) {
            return Expression.RightShift(instance, other);
        }

        public static Lambda<int> RightShift(this Lambda<byte> instance, Lambda<int> other) {
            return Expression.RightShift(instance, other);
        }

        public static Lambda<int> RightShift(this Lambda<short> instance, Lambda<int> other) {
            return Expression.RightShift(instance, other);
        }

        public static Lambda<int> RightShift(this Lambda<ushort> instance, Lambda<int> other) {
            return Expression.RightShift(instance, other);
        }

        public static Lambda<int> RightShift(this Lambda<int> instance, Lambda<int> other) {
            return Expression.RightShift(instance, other);
        }

        public static Lambda<uint> RightShift(this Lambda<uint> instance, Lambda<int> other) {
            return Expression.RightShift(instance, other);
        }

        public static Lambda<long> RightShift(this Lambda<long> instance, Lambda<int> other) {
            return Expression.RightShift(instance, other);
        }

        public static Lambda<ulong> RightShift(this Lambda<ulong> instance, Lambda<int> other) {
            return Expression.RightShift(instance, other);
        }

        public static Lambda<int> Not(this Lambda<sbyte> instance) {
            return Expression.Not(instance);
        }

        public static Lambda<int> Not(this Lambda<byte> instance) {
            return Expression.Not(instance);
        }

        public static Lambda<int> Not(this Lambda<short> instance) {
            return Expression.Not(instance);
        }

        public static Lambda<int> Not(this Lambda<ushort> instance) {
            return Expression.Not(instance);
        }

        public static Lambda<int> Not(this Lambda<int> instance) {
            return Expression.Not(instance);
        }

        public static Lambda<uint> Not(this Lambda<uint> instance) {
            return Expression.Not(instance);
        }

        public static Lambda<long> Not(this Lambda<long> instance) {
            return Expression.Not(instance);
        }

        public static Lambda<ulong> Not(this Lambda<ulong> instance) {
            return Expression.Not(instance);
        }

        public static Lambda<float> Not(this Lambda<float> instance) {
            return Expression.Not(instance);
        }

        public static Lambda<double> Not(this Lambda<double> instance) {
            return Expression.Not(instance);
        }

        public static Lambda<int> Negate(this Lambda<sbyte> instance) {
            return Expression.Negate(instance);
        }

        public static Lambda<int> Negate(this Lambda<byte> instance) {
            return Expression.Negate(instance);
        }

        public static Lambda<int> Negate(this Lambda<short> instance) {
            return Expression.Negate(instance);
        }

        public static Lambda<int> Negate(this Lambda<ushort> instance) {
            return Expression.Negate(instance);
        }

        public static Lambda<int> Negate(this Lambda<int> instance) {
            return Expression.Negate(instance);
        }

        public static Lambda<long> Negate(this Lambda<long> instance) {
            return Expression.Negate(instance);
        }

        public static Lambda<float> Negate(this Lambda<float> instance) {
            return Expression.Negate(instance);
        }

        public static Lambda<double> Negate(this Lambda<double> instance) {
            return Expression.Negate(instance);
        }

    }
}